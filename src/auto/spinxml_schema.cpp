// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "spinxml_schema.hpp"

// vector
// 

const vector::x_type& vector::
x () const
{
  return this->x_.get ();
}

vector::x_type& vector::
x ()
{
  return this->x_.get ();
}

void vector::
x (const x_type& x)
{
  this->x_.set (x);
}

const vector::y_type& vector::
y () const
{
  return this->y_.get ();
}

vector::y_type& vector::
y ()
{
  return this->y_.get ();
}

void vector::
y (const y_type& x)
{
  this->y_.set (x);
}

const vector::z_type& vector::
z () const
{
  return this->z_.get ();
}

vector::z_type& vector::
z ()
{
  return this->z_.get ();
}

void vector::
z (const z_type& x)
{
  this->z_.set (x);
}


// orientation
// 

const orientation::euler_angles_optional& orientation::
euler_angles () const
{
  return this->euler_angles_;
}

orientation::euler_angles_optional& orientation::
euler_angles ()
{
  return this->euler_angles_;
}

void orientation::
euler_angles (const euler_angles_type& x)
{
  this->euler_angles_.set (x);
}

void orientation::
euler_angles (const euler_angles_optional& x)
{
  this->euler_angles_ = x;
}

void orientation::
euler_angles (::std::auto_ptr< euler_angles_type > x)
{
  this->euler_angles_.set (x);
}

const orientation::angle_axis_optional& orientation::
angle_axis () const
{
  return this->angle_axis_;
}

orientation::angle_axis_optional& orientation::
angle_axis ()
{
  return this->angle_axis_;
}

void orientation::
angle_axis (const angle_axis_type& x)
{
  this->angle_axis_.set (x);
}

void orientation::
angle_axis (const angle_axis_optional& x)
{
  this->angle_axis_ = x;
}

void orientation::
angle_axis (::std::auto_ptr< angle_axis_type > x)
{
  this->angle_axis_.set (x);
}

const orientation::quaternion_optional& orientation::
quaternion () const
{
  return this->quaternion_;
}

orientation::quaternion_optional& orientation::
quaternion ()
{
  return this->quaternion_;
}

void orientation::
quaternion (const quaternion_type& x)
{
  this->quaternion_.set (x);
}

void orientation::
quaternion (const quaternion_optional& x)
{
  this->quaternion_ = x;
}

void orientation::
quaternion (::std::auto_ptr< quaternion_type > x)
{
  this->quaternion_.set (x);
}

const orientation::eigensystem_optional& orientation::
eigensystem () const
{
  return this->eigensystem_;
}

orientation::eigensystem_optional& orientation::
eigensystem ()
{
  return this->eigensystem_;
}

void orientation::
eigensystem (const eigensystem_type& x)
{
  this->eigensystem_.set (x);
}

void orientation::
eigensystem (const eigensystem_optional& x)
{
  this->eigensystem_ = x;
}

void orientation::
eigensystem (::std::auto_ptr< eigensystem_type > x)
{
  this->eigensystem_.set (x);
}


// interaction
// 

const interaction::scalar_optional& interaction::
scalar () const
{
  return this->scalar_;
}

interaction::scalar_optional& interaction::
scalar ()
{
  return this->scalar_;
}

void interaction::
scalar (const scalar_type& x)
{
  this->scalar_.set (x);
}

void interaction::
scalar (const scalar_optional& x)
{
  this->scalar_ = x;
}

void interaction::
scalar (::std::auto_ptr< scalar_type > x)
{
  this->scalar_.set (x);
}

const interaction::matrix_optional& interaction::
matrix () const
{
  return this->matrix_;
}

interaction::matrix_optional& interaction::
matrix ()
{
  return this->matrix_;
}

void interaction::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

void interaction::
matrix (const matrix_optional& x)
{
  this->matrix_ = x;
}

void interaction::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}

const interaction::eigenvalues_optional& interaction::
eigenvalues () const
{
  return this->eigenvalues_;
}

interaction::eigenvalues_optional& interaction::
eigenvalues ()
{
  return this->eigenvalues_;
}

void interaction::
eigenvalues (const eigenvalues_type& x)
{
  this->eigenvalues_.set (x);
}

void interaction::
eigenvalues (const eigenvalues_optional& x)
{
  this->eigenvalues_ = x;
}

void interaction::
eigenvalues (::std::auto_ptr< eigenvalues_type > x)
{
  this->eigenvalues_.set (x);
}

const interaction::axiality_rhombicity_optional& interaction::
axiality_rhombicity () const
{
  return this->axiality_rhombicity_;
}

interaction::axiality_rhombicity_optional& interaction::
axiality_rhombicity ()
{
  return this->axiality_rhombicity_;
}

void interaction::
axiality_rhombicity (const axiality_rhombicity_type& x)
{
  this->axiality_rhombicity_.set (x);
}

void interaction::
axiality_rhombicity (const axiality_rhombicity_optional& x)
{
  this->axiality_rhombicity_ = x;
}

void interaction::
axiality_rhombicity (::std::auto_ptr< axiality_rhombicity_type > x)
{
  this->axiality_rhombicity_.set (x);
}

const interaction::span_skew_optional& interaction::
span_skew () const
{
  return this->span_skew_;
}

interaction::span_skew_optional& interaction::
span_skew ()
{
  return this->span_skew_;
}

void interaction::
span_skew (const span_skew_type& x)
{
  this->span_skew_.set (x);
}

void interaction::
span_skew (const span_skew_optional& x)
{
  this->span_skew_ = x;
}

void interaction::
span_skew (::std::auto_ptr< span_skew_type > x)
{
  this->span_skew_.set (x);
}

const interaction::orientation_optional& interaction::
orientation () const
{
  return this->orientation_;
}

interaction::orientation_optional& interaction::
orientation ()
{
  return this->orientation_;
}

void interaction::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void interaction::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void interaction::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const interaction::type_type& interaction::
type () const
{
  return this->type_.get ();
}

interaction::type_type& interaction::
type ()
{
  return this->type_.get ();
}

void interaction::
type (const type_type& x)
{
  this->type_.set (x);
}

void interaction::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const interaction::units_type& interaction::
units () const
{
  return this->units_.get ();
}

interaction::units_type& interaction::
units ()
{
  return this->units_.get ();
}

void interaction::
units (const units_type& x)
{
  this->units_.set (x);
}

void interaction::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}

const interaction::spin_1_type& interaction::
spin_1 () const
{
  return this->spin_1_.get ();
}

interaction::spin_1_type& interaction::
spin_1 ()
{
  return this->spin_1_.get ();
}

void interaction::
spin_1 (const spin_1_type& x)
{
  this->spin_1_.set (x);
}

void interaction::
spin_1 (::std::auto_ptr< spin_1_type > x)
{
  this->spin_1_.set (x);
}

const interaction::spin_2_optional& interaction::
spin_2 () const
{
  return this->spin_2_;
}

interaction::spin_2_optional& interaction::
spin_2 ()
{
  return this->spin_2_;
}

void interaction::
spin_2 (const spin_2_type& x)
{
  this->spin_2_.set (x);
}

void interaction::
spin_2 (const spin_2_optional& x)
{
  this->spin_2_ = x;
}

void interaction::
spin_2 (::std::auto_ptr< spin_2_type > x)
{
  this->spin_2_.set (x);
}


// euler_angles
// 

const euler_angles::alpha_type& euler_angles::
alpha () const
{
  return this->alpha_.get ();
}

euler_angles::alpha_type& euler_angles::
alpha ()
{
  return this->alpha_.get ();
}

void euler_angles::
alpha (const alpha_type& x)
{
  this->alpha_.set (x);
}

void euler_angles::
alpha (::std::auto_ptr< alpha_type > x)
{
  this->alpha_.set (x);
}

const euler_angles::beta_type& euler_angles::
beta () const
{
  return this->beta_.get ();
}

euler_angles::beta_type& euler_angles::
beta ()
{
  return this->beta_.get ();
}

void euler_angles::
beta (const beta_type& x)
{
  this->beta_.set (x);
}

void euler_angles::
beta (::std::auto_ptr< beta_type > x)
{
  this->beta_.set (x);
}

const euler_angles::gamma_type& euler_angles::
gamma () const
{
  return this->gamma_.get ();
}

euler_angles::gamma_type& euler_angles::
gamma ()
{
  return this->gamma_.get ();
}

void euler_angles::
gamma (const gamma_type& x)
{
  this->gamma_.set (x);
}

void euler_angles::
gamma (::std::auto_ptr< gamma_type > x)
{
  this->gamma_.set (x);
}


// angle_axis
// 

const angle_axis::angle_type& angle_axis::
angle () const
{
  return this->angle_.get ();
}

angle_axis::angle_type& angle_axis::
angle ()
{
  return this->angle_.get ();
}

void angle_axis::
angle (const angle_type& x)
{
  this->angle_.set (x);
}

void angle_axis::
angle (::std::auto_ptr< angle_type > x)
{
  this->angle_.set (x);
}

const angle_axis::axis_type& angle_axis::
axis () const
{
  return this->axis_.get ();
}

angle_axis::axis_type& angle_axis::
axis ()
{
  return this->axis_.get ();
}

void angle_axis::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

void angle_axis::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}


// quaternion
// 

const quaternion::re_type& quaternion::
re () const
{
  return this->re_.get ();
}

quaternion::re_type& quaternion::
re ()
{
  return this->re_.get ();
}

void quaternion::
re (const re_type& x)
{
  this->re_.set (x);
}

const quaternion::i_type& quaternion::
i () const
{
  return this->i_.get ();
}

quaternion::i_type& quaternion::
i ()
{
  return this->i_.get ();
}

void quaternion::
i (const i_type& x)
{
  this->i_.set (x);
}

const quaternion::j_type& quaternion::
j () const
{
  return this->j_.get ();
}

quaternion::j_type& quaternion::
j ()
{
  return this->j_.get ();
}

void quaternion::
j (const j_type& x)
{
  this->j_.set (x);
}

const quaternion::k_type& quaternion::
k () const
{
  return this->k_.get ();
}

quaternion::k_type& quaternion::
k ()
{
  return this->k_.get ();
}

void quaternion::
k (const k_type& x)
{
  this->k_.set (x);
}


// eigensystem
// 

const eigensystem::x_axis_type& eigensystem::
x_axis () const
{
  return this->x_axis_.get ();
}

eigensystem::x_axis_type& eigensystem::
x_axis ()
{
  return this->x_axis_.get ();
}

void eigensystem::
x_axis (const x_axis_type& x)
{
  this->x_axis_.set (x);
}

void eigensystem::
x_axis (::std::auto_ptr< x_axis_type > x)
{
  this->x_axis_.set (x);
}

const eigensystem::y_axis_type& eigensystem::
y_axis () const
{
  return this->y_axis_.get ();
}

eigensystem::y_axis_type& eigensystem::
y_axis ()
{
  return this->y_axis_.get ();
}

void eigensystem::
y_axis (const y_axis_type& x)
{
  this->y_axis_.set (x);
}

void eigensystem::
y_axis (::std::auto_ptr< y_axis_type > x)
{
  this->y_axis_.set (x);
}

const eigensystem::z_axis_type& eigensystem::
z_axis () const
{
  return this->z_axis_.get ();
}

eigensystem::z_axis_type& eigensystem::
z_axis ()
{
  return this->z_axis_.get ();
}

void eigensystem::
z_axis (const z_axis_type& x)
{
  this->z_axis_.set (x);
}

void eigensystem::
z_axis (::std::auto_ptr< z_axis_type > x)
{
  this->z_axis_.set (x);
}


// scalar
// 

const scalar::strong_optional& scalar::
strong () const
{
  return this->strong_;
}

scalar::strong_optional& scalar::
strong ()
{
  return this->strong_;
}

void scalar::
strong (const strong_type& x)
{
  this->strong_.set (x);
}

void scalar::
strong (const strong_optional& x)
{
  this->strong_ = x;
}


// matrix
// 

const matrix::element_sequence& matrix::
element () const
{
  return this->element_;
}

matrix::element_sequence& matrix::
element ()
{
  return this->element_;
}

void matrix::
element (const element_sequence& s)
{
  this->element_ = s;
}


// eigenvalues
// 

const eigenvalues::XX_type& eigenvalues::
XX () const
{
  return this->XX_.get ();
}

eigenvalues::XX_type& eigenvalues::
XX ()
{
  return this->XX_.get ();
}

void eigenvalues::
XX (const XX_type& x)
{
  this->XX_.set (x);
}

const eigenvalues::YY_type& eigenvalues::
YY () const
{
  return this->YY_.get ();
}

eigenvalues::YY_type& eigenvalues::
YY ()
{
  return this->YY_.get ();
}

void eigenvalues::
YY (const YY_type& x)
{
  this->YY_.set (x);
}

const eigenvalues::ZZ_type& eigenvalues::
ZZ () const
{
  return this->ZZ_.get ();
}

eigenvalues::ZZ_type& eigenvalues::
ZZ ()
{
  return this->ZZ_.get ();
}

void eigenvalues::
ZZ (const ZZ_type& x)
{
  this->ZZ_.set (x);
}


// axiality_rhombicity
// 

const axiality_rhombicity::iso_type& axiality_rhombicity::
iso () const
{
  return this->iso_.get ();
}

axiality_rhombicity::iso_type& axiality_rhombicity::
iso ()
{
  return this->iso_.get ();
}

void axiality_rhombicity::
iso (const iso_type& x)
{
  this->iso_.set (x);
}

const axiality_rhombicity::ax_type& axiality_rhombicity::
ax () const
{
  return this->ax_.get ();
}

axiality_rhombicity::ax_type& axiality_rhombicity::
ax ()
{
  return this->ax_.get ();
}

void axiality_rhombicity::
ax (const ax_type& x)
{
  this->ax_.set (x);
}

const axiality_rhombicity::rh_type& axiality_rhombicity::
rh () const
{
  return this->rh_.get ();
}

axiality_rhombicity::rh_type& axiality_rhombicity::
rh ()
{
  return this->rh_.get ();
}

void axiality_rhombicity::
rh (const rh_type& x)
{
  this->rh_.set (x);
}


// span_skew
// 

const span_skew::iso_type& span_skew::
iso () const
{
  return this->iso_.get ();
}

span_skew::iso_type& span_skew::
iso ()
{
  return this->iso_.get ();
}

void span_skew::
iso (const iso_type& x)
{
  this->iso_.set (x);
}

const span_skew::span_type& span_skew::
span () const
{
  return this->span_.get ();
}

span_skew::span_type& span_skew::
span ()
{
  return this->span_.get ();
}

void span_skew::
span (const span_type& x)
{
  this->span_.set (x);
}

const span_skew::skew_type& span_skew::
skew () const
{
  return this->skew_.get ();
}

span_skew::skew_type& span_skew::
skew ()
{
  return this->skew_.get ();
}

void span_skew::
skew (const skew_type& x)
{
  this->skew_.set (x);
}


// type
// 

type::
type (value v)
: ::xml_schema::string (_xsd_type_literals_[v])
{
}

type::
type (const char* v)
: ::xml_schema::string (v)
{
}

type::
type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

type::
type (const type& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

type& type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_type_literals_[v]);

  return *this;
}


// spin_1
// 


// spin_2
// 


// spin_system
// 

const spin_system::spin_sequence& spin_system::
spin () const
{
  return this->spin_;
}

spin_system::spin_sequence& spin_system::
spin ()
{
  return this->spin_;
}

void spin_system::
spin (const spin_sequence& s)
{
  this->spin_ = s;
}

const spin_system::interaction_sequence& spin_system::
interaction () const
{
  return this->interaction_;
}

spin_system::interaction_sequence& spin_system::
interaction ()
{
  return this->interaction_;
}

void spin_system::
interaction (const interaction_sequence& s)
{
  this->interaction_ = s;
}

const spin_system::reference_frame_sequence& spin_system::
reference_frame () const
{
  return this->reference_frame_;
}

spin_system::reference_frame_sequence& spin_system::
reference_frame ()
{
  return this->reference_frame_;
}

void spin_system::
reference_frame (const reference_frame_sequence& s)
{
  this->reference_frame_ = s;
}


// alpha
// 


// beta
// 


// gamma
// 


// angle
// 


// spin
// 

const spin::coordinates_type& spin::
coordinates () const
{
  return this->coordinates_.get ();
}

spin::coordinates_type& spin::
coordinates ()
{
  return this->coordinates_.get ();
}

void spin::
coordinates (const coordinates_type& x)
{
  this->coordinates_.set (x);
}

void spin::
coordinates (::std::auto_ptr< coordinates_type > x)
{
  this->coordinates_.set (x);
}

const spin::isotope_sequence& spin::
isotope () const
{
  return this->isotope_;
}

spin::isotope_sequence& spin::
isotope ()
{
  return this->isotope_;
}

void spin::
isotope (const isotope_sequence& s)
{
  this->isotope_ = s;
}

const spin::number_type& spin::
number () const
{
  return this->number_.get ();
}

spin::number_type& spin::
number ()
{
  return this->number_.get ();
}

void spin::
number (const number_type& x)
{
  this->number_.set (x);
}

void spin::
number (::std::auto_ptr< number_type > x)
{
  this->number_.set (x);
}

const spin::label_optional& spin::
label () const
{
  return this->label_;
}

spin::label_optional& spin::
label ()
{
  return this->label_;
}

void spin::
label (const label_type& x)
{
  this->label_.set (x);
}

void spin::
label (const label_optional& x)
{
  this->label_ = x;
}

void spin::
label (::std::auto_ptr< label_type > x)
{
  this->label_.set (x);
}

const spin::reference_frame_type& spin::
reference_frame () const
{
  return this->reference_frame_.get ();
}

spin::reference_frame_type& spin::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void spin::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}

void spin::
reference_frame (::std::auto_ptr< reference_frame_type > x)
{
  this->reference_frame_.set (x);
}

const spin::element_type& spin::
element () const
{
  return this->element_.get ();
}

spin::element_type& spin::
element ()
{
  return this->element_.get ();
}

void spin::
element (const element_type& x)
{
  this->element_.set (x);
}

void spin::
element (::std::auto_ptr< element_type > x)
{
  this->element_.set (x);
}

const spin::element_type& spin::
element_default_value ()
{
  return element_default_value_;
}


// interaction1
// 

const interaction1::reference_frame_type& interaction1::
reference_frame () const
{
  return this->reference_frame_.get ();
}

interaction1::reference_frame_type& interaction1::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void interaction1::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}

void interaction1::
reference_frame (::std::auto_ptr< reference_frame_type > x)
{
  this->reference_frame_.set (x);
}


// reference_frame
// 

const reference_frame::origin_type& reference_frame::
origin () const
{
  return this->origin_.get ();
}

reference_frame::origin_type& reference_frame::
origin ()
{
  return this->origin_.get ();
}

void reference_frame::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void reference_frame::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const reference_frame::orientation_type& reference_frame::
orientation () const
{
  return this->orientation_.get ();
}

reference_frame::orientation_type& reference_frame::
orientation ()
{
  return this->orientation_.get ();
}

void reference_frame::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void reference_frame::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const reference_frame::number_type& reference_frame::
number () const
{
  return this->number_.get ();
}

reference_frame::number_type& reference_frame::
number ()
{
  return this->number_.get ();
}

void reference_frame::
number (const number_type& x)
{
  this->number_.set (x);
}

void reference_frame::
number (::std::auto_ptr< number_type > x)
{
  this->number_.set (x);
}

const reference_frame::label_optional& reference_frame::
label () const
{
  return this->label_;
}

reference_frame::label_optional& reference_frame::
label ()
{
  return this->label_;
}

void reference_frame::
label (const label_type& x)
{
  this->label_.set (x);
}

void reference_frame::
label (const label_optional& x)
{
  this->label_ = x;
}

void reference_frame::
label (::std::auto_ptr< label_type > x)
{
  this->label_.set (x);
}

const reference_frame::reference_frame1_optional& reference_frame::
reference_frame1 () const
{
  return this->reference_frame1_;
}

reference_frame::reference_frame1_optional& reference_frame::
reference_frame1 ()
{
  return this->reference_frame1_;
}

void reference_frame::
reference_frame1 (const reference_frame1_type& x)
{
  this->reference_frame1_.set (x);
}

void reference_frame::
reference_frame1 (const reference_frame1_optional& x)
{
  this->reference_frame1_ = x;
}

void reference_frame::
reference_frame1 (::std::auto_ptr< reference_frame1_type > x)
{
  this->reference_frame1_.set (x);
}


// isotope
// 

const isotope::abundance_optional& isotope::
abundance () const
{
  return this->abundance_;
}

isotope::abundance_optional& isotope::
abundance ()
{
  return this->abundance_;
}

void isotope::
abundance (const abundance_type& x)
{
  this->abundance_.set (x);
}

void isotope::
abundance (const abundance_optional& x)
{
  this->abundance_ = x;
}

void isotope::
abundance (::std::auto_ptr< abundance_type > x)
{
  this->abundance_.set (x);
}

const isotope::mass_number_optional& isotope::
mass_number () const
{
  return this->mass_number_;
}

isotope::mass_number_optional& isotope::
mass_number ()
{
  return this->mass_number_;
}

void isotope::
mass_number (const mass_number_type& x)
{
  this->mass_number_.set (x);
}

void isotope::
mass_number (const mass_number_optional& x)
{
  this->mass_number_ = x;
}

void isotope::
mass_number (::std::auto_ptr< mass_number_type > x)
{
  this->mass_number_.set (x);
}


// number
// 


// reference_frame1
// 


// element
// 


// reference_frame2
// 


// number1
// 


// reference_frame3
// 


// abundance
// 


// mass_number
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// vector
//

vector::
vector (const x_type& x,
        const y_type& y,
        const z_type& z)
: ::xml_schema::type (),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this),
  z_ (z, ::xml_schema::flags (), this)
{
}

vector::
vector (const vector& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

vector::
vector (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (f, this),
  y_ (f, this),
  z_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }
}

vector* vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vector (*this, f, c);
}

vector::
~vector ()
{
}

// orientation
//

orientation::
orientation ()
: ::xml_schema::type (),
  euler_angles_ (::xml_schema::flags (), this),
  angle_axis_ (::xml_schema::flags (), this),
  quaternion_ (::xml_schema::flags (), this),
  eigensystem_ (::xml_schema::flags (), this)
{
}

orientation::
orientation (const orientation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  euler_angles_ (x.euler_angles_, f, this),
  angle_axis_ (x.angle_axis_, f, this),
  quaternion_ (x.quaternion_, f, this),
  eigensystem_ (x.eigensystem_, f, this)
{
}

orientation::
orientation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  euler_angles_ (f, this),
  angle_axis_ (f, this),
  quaternion_ (f, this),
  eigensystem_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void orientation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // euler_angles
    //
    if (n.name () == "euler_angles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< euler_angles_type > r (
        euler_angles_traits::create (i, f, this));

      if (!this->euler_angles_)
      {
        this->euler_angles_.set (r);
        continue;
      }
    }

    // angle_axis
    //
    if (n.name () == "angle_axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< angle_axis_type > r (
        angle_axis_traits::create (i, f, this));

      if (!this->angle_axis_)
      {
        this->angle_axis_.set (r);
        continue;
      }
    }

    // quaternion
    //
    if (n.name () == "quaternion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< quaternion_type > r (
        quaternion_traits::create (i, f, this));

      if (!this->quaternion_)
      {
        this->quaternion_.set (r);
        continue;
      }
    }

    // eigensystem
    //
    if (n.name () == "eigensystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eigensystem_type > r (
        eigensystem_traits::create (i, f, this));

      if (!this->eigensystem_)
      {
        this->eigensystem_.set (r);
        continue;
      }
    }

    break;
  }
}

orientation* orientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class orientation (*this, f, c);
}

orientation::
~orientation ()
{
}

// interaction
//

interaction::
interaction (const type_type& type,
             const units_type& units,
             const spin_1_type& spin_1)
: ::xml_schema::type (),
  scalar_ (::xml_schema::flags (), this),
  matrix_ (::xml_schema::flags (), this),
  eigenvalues_ (::xml_schema::flags (), this),
  axiality_rhombicity_ (::xml_schema::flags (), this),
  span_skew_ (::xml_schema::flags (), this),
  orientation_ (::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this),
  units_ (units, ::xml_schema::flags (), this),
  spin_1_ (spin_1, ::xml_schema::flags (), this),
  spin_2_ (::xml_schema::flags (), this)
{
}

interaction::
interaction (const interaction& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  scalar_ (x.scalar_, f, this),
  matrix_ (x.matrix_, f, this),
  eigenvalues_ (x.eigenvalues_, f, this),
  axiality_rhombicity_ (x.axiality_rhombicity_, f, this),
  span_skew_ (x.span_skew_, f, this),
  orientation_ (x.orientation_, f, this),
  type_ (x.type_, f, this),
  units_ (x.units_, f, this),
  spin_1_ (x.spin_1_, f, this),
  spin_2_ (x.spin_2_, f, this)
{
}

interaction::
interaction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  scalar_ (f, this),
  matrix_ (f, this),
  eigenvalues_ (f, this),
  axiality_rhombicity_ (f, this),
  span_skew_ (f, this),
  orientation_ (f, this),
  type_ (f, this),
  units_ (f, this),
  spin_1_ (f, this),
  spin_2_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void interaction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // scalar
    //
    if (n.name () == "scalar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scalar_type > r (
        scalar_traits::create (i, f, this));

      if (!this->scalar_)
      {
        this->scalar_.set (r);
        continue;
      }
    }

    // matrix
    //
    if (n.name () == "matrix" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< matrix_type > r (
        matrix_traits::create (i, f, this));

      if (!this->matrix_)
      {
        this->matrix_.set (r);
        continue;
      }
    }

    // eigenvalues
    //
    if (n.name () == "eigenvalues" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eigenvalues_type > r (
        eigenvalues_traits::create (i, f, this));

      if (!this->eigenvalues_)
      {
        this->eigenvalues_.set (r);
        continue;
      }
    }

    // axiality_rhombicity
    //
    if (n.name () == "axiality_rhombicity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axiality_rhombicity_type > r (
        axiality_rhombicity_traits::create (i, f, this));

      if (!this->axiality_rhombicity_)
      {
        this->axiality_rhombicity_.set (r);
        continue;
      }
    }

    // span_skew
    //
    if (n.name () == "span_skew" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< span_skew_type > r (
        span_skew_traits::create (i, f, this));

      if (!this->span_skew_)
      {
        this->span_skew_.set (r);
        continue;
      }
    }

    // orientation
    //
    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      if (!this->orientation_)
      {
        this->orientation_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type_.set (r);
      continue;
    }

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }

    if (n.name () == "spin_1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spin_1_type > r (
        spin_1_traits::create (i, f, this));

      this->spin_1_.set (r);
      continue;
    }

    if (n.name () == "spin_2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spin_2_type > r (
        spin_2_traits::create (i, f, this));

      this->spin_2_.set (r);
      continue;
    }
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }

  if (!spin_1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "spin_1",
      "");
  }
}

interaction* interaction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class interaction (*this, f, c);
}

interaction::
~interaction ()
{
}

// euler_angles
//

euler_angles::
euler_angles (const alpha_type& alpha,
              const beta_type& beta,
              const gamma_type& gamma)
: ::xml_schema::type (),
  alpha_ (alpha, ::xml_schema::flags (), this),
  beta_ (beta, ::xml_schema::flags (), this),
  gamma_ (gamma, ::xml_schema::flags (), this)
{
}

euler_angles::
euler_angles (const euler_angles& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  alpha_ (x.alpha_, f, this),
  beta_ (x.beta_, f, this),
  gamma_ (x.gamma_, f, this)
{
}

euler_angles::
euler_angles (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  alpha_ (f, this),
  beta_ (f, this),
  gamma_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void euler_angles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "alpha" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< alpha_type > r (
        alpha_traits::create (i, f, this));

      this->alpha_.set (r);
      continue;
    }

    if (n.name () == "beta" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< beta_type > r (
        beta_traits::create (i, f, this));

      this->beta_.set (r);
      continue;
    }

    if (n.name () == "gamma" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< gamma_type > r (
        gamma_traits::create (i, f, this));

      this->gamma_.set (r);
      continue;
    }
  }

  if (!alpha_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "alpha",
      "");
  }

  if (!beta_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "beta",
      "");
  }

  if (!gamma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "gamma",
      "");
  }
}

euler_angles* euler_angles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class euler_angles (*this, f, c);
}

euler_angles::
~euler_angles ()
{
}

// angle_axis
//

angle_axis::
angle_axis (const angle_type& angle,
            const axis_type& axis)
: ::xml_schema::type (),
  angle_ (angle, ::xml_schema::flags (), this),
  axis_ (axis, ::xml_schema::flags (), this)
{
}

angle_axis::
angle_axis (const angle_type& angle,
            ::std::auto_ptr< axis_type >& axis)
: ::xml_schema::type (),
  angle_ (angle, ::xml_schema::flags (), this),
  axis_ (axis, ::xml_schema::flags (), this)
{
}

angle_axis::
angle_axis (const angle_axis& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  angle_ (x.angle_, f, this),
  axis_ (x.axis_, f, this)
{
}

angle_axis::
angle_axis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  angle_ (f, this),
  axis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void angle_axis::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // angle
    //
    if (n.name () == "angle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< angle_type > r (
        angle_traits::create (i, f, this));

      if (!angle_.present ())
      {
        this->angle_.set (r);
        continue;
      }
    }

    // axis
    //
    if (n.name () == "axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axis_type > r (
        axis_traits::create (i, f, this));

      if (!axis_.present ())
      {
        this->axis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!angle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "angle",
      "");
  }

  if (!axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "axis",
      "");
  }
}

angle_axis* angle_axis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class angle_axis (*this, f, c);
}

angle_axis::
~angle_axis ()
{
}

// quaternion
//

quaternion::
quaternion (const re_type& re,
            const i_type& i,
            const j_type& j,
            const k_type& k)
: ::xml_schema::type (),
  re_ (re, ::xml_schema::flags (), this),
  i_ (i, ::xml_schema::flags (), this),
  j_ (j, ::xml_schema::flags (), this),
  k_ (k, ::xml_schema::flags (), this)
{
}

quaternion::
quaternion (const quaternion& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  re_ (x.re_, f, this),
  i_ (x.i_, f, this),
  j_ (x.j_, f, this),
  k_ (x.k_, f, this)
{
}

quaternion::
quaternion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  re_ (f, this),
  i_ (f, this),
  j_ (f, this),
  k_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void quaternion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "re" && n.namespace_ ().empty ())
    {
      this->re_.set (re_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "i" && n.namespace_ ().empty ())
    {
      this->i_.set (i_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "j" && n.namespace_ ().empty ())
    {
      this->j_.set (j_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      this->k_.set (k_traits::create (i, f, this));
      continue;
    }
  }

  if (!re_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "re",
      "");
  }

  if (!i_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "i",
      "");
  }

  if (!j_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "j",
      "");
  }

  if (!k_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "k",
      "");
  }
}

quaternion* quaternion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class quaternion (*this, f, c);
}

quaternion::
~quaternion ()
{
}

// eigensystem
//

eigensystem::
eigensystem (const x_axis_type& x_axis,
             const y_axis_type& y_axis,
             const z_axis_type& z_axis)
: ::xml_schema::type (),
  x_axis_ (x_axis, ::xml_schema::flags (), this),
  y_axis_ (y_axis, ::xml_schema::flags (), this),
  z_axis_ (z_axis, ::xml_schema::flags (), this)
{
}

eigensystem::
eigensystem (::std::auto_ptr< x_axis_type >& x_axis,
             ::std::auto_ptr< y_axis_type >& y_axis,
             ::std::auto_ptr< z_axis_type >& z_axis)
: ::xml_schema::type (),
  x_axis_ (x_axis, ::xml_schema::flags (), this),
  y_axis_ (y_axis, ::xml_schema::flags (), this),
  z_axis_ (z_axis, ::xml_schema::flags (), this)
{
}

eigensystem::
eigensystem (const eigensystem& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_axis_ (x.x_axis_, f, this),
  y_axis_ (x.y_axis_, f, this),
  z_axis_ (x.z_axis_, f, this)
{
}

eigensystem::
eigensystem (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_axis_ (f, this),
  y_axis_ (f, this),
  z_axis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void eigensystem::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x_axis
    //
    if (n.name () == "x_axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< x_axis_type > r (
        x_axis_traits::create (i, f, this));

      if (!x_axis_.present ())
      {
        this->x_axis_.set (r);
        continue;
      }
    }

    // y_axis
    //
    if (n.name () == "y_axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< y_axis_type > r (
        y_axis_traits::create (i, f, this));

      if (!y_axis_.present ())
      {
        this->y_axis_.set (r);
        continue;
      }
    }

    // z_axis
    //
    if (n.name () == "z_axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< z_axis_type > r (
        z_axis_traits::create (i, f, this));

      if (!z_axis_.present ())
      {
        this->z_axis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!x_axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x_axis",
      "");
  }

  if (!y_axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y_axis",
      "");
  }

  if (!z_axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z_axis",
      "");
  }
}

eigensystem* eigensystem::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class eigensystem (*this, f, c);
}

eigensystem::
~eigensystem ()
{
}

// scalar
//

scalar::
scalar (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base),
  strong_ (::xml_schema::flags (), this)
{
}

scalar::
scalar (const scalar& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
  strong_ (x.strong_, f, this)
{
}

scalar::
scalar (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::flags::base, c),
  strong_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void scalar::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "strong" && n.namespace_ ().empty ())
    {
      this->strong_.set (strong_traits::create (i, f, this));
      continue;
    }
  }
}

scalar* scalar::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class scalar (*this, f, c);
}

scalar::
~scalar ()
{
}

// matrix
//

matrix::
matrix ()
: ::xml_schema::type (),
  element_ (::xml_schema::flags (), this)
{
}

matrix::
matrix (const matrix& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  element_ (x.element_, f, this)
{
}

matrix::
matrix (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  element_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void matrix::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // element
    //
    if (n.name () == "element" && n.namespace_ ().empty ())
    {
      this->element_.push_back (element_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

matrix* matrix::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class matrix (*this, f, c);
}

matrix::
~matrix ()
{
}

// eigenvalues
//

eigenvalues::
eigenvalues (const XX_type& XX,
             const YY_type& YY,
             const ZZ_type& ZZ)
: ::xml_schema::type (),
  XX_ (XX, ::xml_schema::flags (), this),
  YY_ (YY, ::xml_schema::flags (), this),
  ZZ_ (ZZ, ::xml_schema::flags (), this)
{
}

eigenvalues::
eigenvalues (const eigenvalues& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  XX_ (x.XX_, f, this),
  YY_ (x.YY_, f, this),
  ZZ_ (x.ZZ_, f, this)
{
}

eigenvalues::
eigenvalues (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  XX_ (f, this),
  YY_ (f, this),
  ZZ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void eigenvalues::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "XX" && n.namespace_ ().empty ())
    {
      this->XX_.set (XX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "YY" && n.namespace_ ().empty ())
    {
      this->YY_.set (YY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ZZ" && n.namespace_ ().empty ())
    {
      this->ZZ_.set (ZZ_traits::create (i, f, this));
      continue;
    }
  }

  if (!XX_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "XX",
      "");
  }

  if (!YY_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "YY",
      "");
  }

  if (!ZZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ZZ",
      "");
  }
}

eigenvalues* eigenvalues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class eigenvalues (*this, f, c);
}

eigenvalues::
~eigenvalues ()
{
}

// axiality_rhombicity
//

axiality_rhombicity::
axiality_rhombicity (const iso_type& iso,
                     const ax_type& ax,
                     const rh_type& rh)
: ::xml_schema::type (),
  iso_ (iso, ::xml_schema::flags (), this),
  ax_ (ax, ::xml_schema::flags (), this),
  rh_ (rh, ::xml_schema::flags (), this)
{
}

axiality_rhombicity::
axiality_rhombicity (const axiality_rhombicity& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  iso_ (x.iso_, f, this),
  ax_ (x.ax_, f, this),
  rh_ (x.rh_, f, this)
{
}

axiality_rhombicity::
axiality_rhombicity (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  iso_ (f, this),
  ax_ (f, this),
  rh_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void axiality_rhombicity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "iso" && n.namespace_ ().empty ())
    {
      this->iso_.set (iso_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ax" && n.namespace_ ().empty ())
    {
      this->ax_.set (ax_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rh" && n.namespace_ ().empty ())
    {
      this->rh_.set (rh_traits::create (i, f, this));
      continue;
    }
  }

  if (!iso_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iso",
      "");
  }

  if (!ax_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ax",
      "");
  }

  if (!rh_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "rh",
      "");
  }
}

axiality_rhombicity* axiality_rhombicity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class axiality_rhombicity (*this, f, c);
}

axiality_rhombicity::
~axiality_rhombicity ()
{
}

// span_skew
//

span_skew::
span_skew (const iso_type& iso,
           const span_type& span,
           const skew_type& skew)
: ::xml_schema::type (),
  iso_ (iso, ::xml_schema::flags (), this),
  span_ (span, ::xml_schema::flags (), this),
  skew_ (skew, ::xml_schema::flags (), this)
{
}

span_skew::
span_skew (const span_skew& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  iso_ (x.iso_, f, this),
  span_ (x.span_, f, this),
  skew_ (x.skew_, f, this)
{
}

span_skew::
span_skew (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  iso_ (f, this),
  span_ (f, this),
  skew_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void span_skew::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "iso" && n.namespace_ ().empty ())
    {
      this->iso_.set (iso_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "span" && n.namespace_ ().empty ())
    {
      this->span_.set (span_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "skew" && n.namespace_ ().empty ())
    {
      this->skew_.set (skew_traits::create (i, f, this));
      continue;
    }
  }

  if (!iso_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iso",
      "");
  }

  if (!span_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "span",
      "");
  }

  if (!skew_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "skew",
      "");
  }
}

span_skew* span_skew::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class span_skew (*this, f, c);
}

span_skew::
~span_skew ()
{
}

// type
//

type::
type (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_type_convert ();
}

type::
type (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_type_convert ();
}

type* type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class type (*this, f, c);
}

type::value type::
_xsd_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_type_indexes_,
                    _xsd_type_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_type_indexes_ + 9 || _xsd_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const type::
_xsd_type_literals_[9] =
{
  "hfc",
  "shielding",
  "quadrupolar",
  "scalar",
  "dipolar",
  "g-tenser",
  "zfs",
  "exchange",
  "custem"
};

const type::value type::
_xsd_type_indexes_[9] =
{
  ::type::custem,
  ::type::dipolar,
  ::type::exchange,
  ::type::g_tenser,
  ::type::hfc,
  ::type::quadrupolar,
  ::type::scalar,
  ::type::shielding,
  ::type::zfs
};

// spin_1
//

spin_1::
spin_1 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

spin_1::
spin_1 (const spin_1& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

spin_1::
spin_1 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

spin_1::
spin_1 (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

spin_1::
spin_1 (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

spin_1* spin_1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin_1 (*this, f, c);
}

spin_1::
~spin_1 ()
{
}

// spin_2
//

spin_2::
spin_2 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

spin_2::
spin_2 (const spin_2& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

spin_2::
spin_2 (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

spin_2::
spin_2 (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

spin_2::
spin_2 (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

spin_2* spin_2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin_2 (*this, f, c);
}

spin_2::
~spin_2 ()
{
}

// spin_system
//

spin_system::
spin_system ()
: ::xml_schema::type (),
  spin_ (::xml_schema::flags (), this),
  interaction_ (::xml_schema::flags (), this),
  reference_frame_ (::xml_schema::flags (), this)
{
}

spin_system::
spin_system (const spin_system& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  spin_ (x.spin_, f, this),
  interaction_ (x.interaction_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

spin_system::
spin_system (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  spin_ (f, this),
  interaction_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void spin_system::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // spin
    //
    if (n.name () == "spin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spin_type > r (
        spin_traits::create (i, f, this));

      this->spin_.push_back (r);
      continue;
    }

    // interaction
    //
    if (n.name () == "interaction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< interaction_type > r (
        interaction_traits::create (i, f, this));

      this->interaction_.push_back (r);
      continue;
    }

    // reference_frame
    //
    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_frame_type > r (
        reference_frame_traits::create (i, f, this));

      this->reference_frame_.push_back (r);
      continue;
    }

    break;
  }
}

spin_system* spin_system::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin_system (*this, f, c);
}

spin_system::
~spin_system ()
{
}

// alpha
//

alpha::
alpha (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

alpha::
alpha (const alpha& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

alpha::
alpha (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

alpha::
alpha (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

alpha::
alpha (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

alpha* alpha::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class alpha (*this, f, c);
}

alpha::
~alpha ()
{
}

// beta
//

beta::
beta (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

beta::
beta (const beta& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

beta::
beta (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

beta::
beta (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

beta::
beta (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

beta* beta::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class beta (*this, f, c);
}

beta::
~beta ()
{
}

// gamma
//

gamma::
gamma (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

gamma::
gamma (const gamma& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

gamma::
gamma (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

gamma::
gamma (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

gamma::
gamma (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

gamma* gamma::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gamma (*this, f, c);
}

gamma::
~gamma ()
{
}

// angle
//

angle::
angle (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

angle::
angle (const angle& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

angle::
angle (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

angle::
angle (const ::xercesc::DOMAttr& a,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

angle::
angle (const ::std::string& s,
       const ::xercesc::DOMElement* e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

angle* angle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class angle (*this, f, c);
}

angle::
~angle ()
{
}

// spin
//

const spin::element_type spin::element_default_value_ (
  ::std::string ("H"), 0, 0, 0);

spin::
spin (const coordinates_type& coordinates,
      const number_type& number,
      const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  coordinates_ (coordinates, ::xml_schema::flags (), this),
  isotope_ (::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this),
  element_ (element_default_value (), ::xml_schema::flags (), this)
{
}

spin::
spin (::std::auto_ptr< coordinates_type >& coordinates,
      const number_type& number,
      const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  coordinates_ (coordinates, ::xml_schema::flags (), this),
  isotope_ (::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this),
  element_ (element_default_value (), ::xml_schema::flags (), this)
{
}

spin::
spin (const spin& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinates_ (x.coordinates_, f, this),
  isotope_ (x.isotope_, f, this),
  number_ (x.number_, f, this),
  label_ (x.label_, f, this),
  reference_frame_ (x.reference_frame_, f, this),
  element_ (x.element_, f, this)
{
}

spin::
spin (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinates_ (f, this),
  isotope_ (f, this),
  number_ (f, this),
  label_ (f, this),
  reference_frame_ (f, this),
  element_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void spin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinates
    //
    if (n.name () == "coordinates" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordinates_type > r (
        coordinates_traits::create (i, f, this));

      if (!coordinates_.present ())
      {
        this->coordinates_.set (r);
        continue;
      }
    }

    // isotope
    //
    if (n.name () == "isotope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< isotope_type > r (
        isotope_traits::create (i, f, this));

      this->isotope_.push_back (r);
      continue;
    }

    break;
  }

  if (!coordinates_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinates",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< number_type > r (
        number_traits::create (i, f, this));

      this->number_.set (r);
      continue;
    }

    if (n.name () == "label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< label_type > r (
        label_traits::create (i, f, this));

      this->label_.set (r);
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_frame_type > r (
        reference_frame_traits::create (i, f, this));

      this->reference_frame_.set (r);
      continue;
    }

    if (n.name () == "element" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< element_type > r (
        element_traits::create (i, f, this));

      this->element_.set (r);
      continue;
    }
  }

  if (!number_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "number",
      "");
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }

  if (!element_.present ())
  {
    this->element_.set (element_default_value ());
  }
}

spin* spin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin (*this, f, c);
}

spin::
~spin ()
{
}

// interaction1
//

interaction1::
interaction1 (const type_type& type,
              const units_type& units,
              const spin_1_type& spin_1,
              const reference_frame_type& reference_frame)
: ::interaction (type,
                 units,
                 spin_1),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this)
{
}

interaction1::
interaction1 (const interaction1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::interaction (x, f, c),
  reference_frame_ (x.reference_frame_, f, this)
{
}

interaction1::
interaction1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::interaction (e, f | ::xml_schema::flags::base, c),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void interaction1::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::interaction::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_frame_type > r (
        reference_frame_traits::create (i, f, this));

      this->reference_frame_.set (r);
      continue;
    }
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }
}

interaction1* interaction1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class interaction1 (*this, f, c);
}

interaction1::
~interaction1 ()
{
}

// reference_frame
//

reference_frame::
reference_frame (const origin_type& origin,
                 const orientation_type& orientation,
                 const number_type& number)
: ::xml_schema::type (),
  origin_ (origin, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this),
  reference_frame1_ (::xml_schema::flags (), this)
{
}

reference_frame::
reference_frame (::std::auto_ptr< origin_type >& origin,
                 ::std::auto_ptr< orientation_type >& orientation,
                 const number_type& number)
: ::xml_schema::type (),
  origin_ (origin, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this),
  reference_frame1_ (::xml_schema::flags (), this)
{
}

reference_frame::
reference_frame (const reference_frame& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  orientation_ (x.orientation_, f, this),
  number_ (x.number_, f, this),
  label_ (x.label_, f, this),
  reference_frame1_ (x.reference_frame1_, f, this)
{
}

reference_frame::
reference_frame (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (f, this),
  orientation_ (f, this),
  number_ (f, this),
  label_ (f, this),
  reference_frame1_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void reference_frame::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // orientation
    //
    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      if (!orientation_.present ())
      {
        this->orientation_.set (r);
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "orientation",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< number_type > r (
        number_traits::create (i, f, this));

      this->number_.set (r);
      continue;
    }

    if (n.name () == "label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< label_type > r (
        label_traits::create (i, f, this));

      this->label_.set (r);
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_frame1_type > r (
        reference_frame1_traits::create (i, f, this));

      this->reference_frame1_.set (r);
      continue;
    }
  }

  if (!number_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "number",
      "");
  }
}

reference_frame* reference_frame::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class reference_frame (*this, f, c);
}

reference_frame::
~reference_frame ()
{
}

// isotope
//

isotope::
isotope ()
: ::xml_schema::type (),
  abundance_ (::xml_schema::flags (), this),
  mass_number_ (::xml_schema::flags (), this)
{
}

isotope::
isotope (const isotope& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  abundance_ (x.abundance_, f, this),
  mass_number_ (x.mass_number_, f, this)
{
}

isotope::
isotope (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  abundance_ (f, this),
  mass_number_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void isotope::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "abundance" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< abundance_type > r (
        abundance_traits::create (i, f, this));

      this->abundance_.set (r);
      continue;
    }

    if (n.name () == "mass_number" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mass_number_type > r (
        mass_number_traits::create (i, f, this));

      this->mass_number_.set (r);
      continue;
    }
  }
}

isotope* isotope::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class isotope (*this, f, c);
}

isotope::
~isotope ()
{
}

// number
//

number::
number (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

number::
number (const number& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

number::
number (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

number::
number (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

number::
number (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

number* number::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class number (*this, f, c);
}

number::
~number ()
{
}

// reference_frame1
//

reference_frame1::
reference_frame1 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

reference_frame1::
reference_frame1 (const reference_frame1& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

reference_frame1::
reference_frame1 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

reference_frame1::
reference_frame1 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

reference_frame1::
reference_frame1 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

reference_frame1* reference_frame1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class reference_frame1 (*this, f, c);
}

reference_frame1::
~reference_frame1 ()
{
}

// element
//

element::
element ()
: ::xml_schema::string ()
{
}

element::
element (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

element::
element (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

element::
element (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

element::
element (const element& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

element::
element (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

element::
element (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

element::
element (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

element* element::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class element (*this, f, c);
}

element::
~element ()
{
}

// reference_frame2
//

reference_frame2::
reference_frame2 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

reference_frame2::
reference_frame2 (const reference_frame2& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

reference_frame2::
reference_frame2 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

reference_frame2::
reference_frame2 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

reference_frame2::
reference_frame2 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

reference_frame2* reference_frame2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class reference_frame2 (*this, f, c);
}

reference_frame2::
~reference_frame2 ()
{
}

// number1
//

number1::
number1 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

number1::
number1 (const number1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

number1::
number1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

number1::
number1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

number1::
number1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

number1* number1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class number1 (*this, f, c);
}

number1::
~number1 ()
{
}

// reference_frame3
//

reference_frame3::
reference_frame3 (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

reference_frame3::
reference_frame3 (const reference_frame3& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

reference_frame3::
reference_frame3 (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

reference_frame3::
reference_frame3 (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

reference_frame3::
reference_frame3 (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

reference_frame3* reference_frame3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class reference_frame3 (*this, f, c);
}

reference_frame3::
~reference_frame3 ()
{
}

// abundance
//

abundance::
abundance (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

abundance::
abundance (const abundance& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

abundance::
abundance (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

abundance::
abundance (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

abundance::
abundance (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

abundance* abundance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class abundance (*this, f, c);
}

abundance::
~abundance ()
{
}

// mass_number
//

mass_number::
mass_number (const ::xml_schema::integer& _xsd_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
{
}

mass_number::
mass_number (const mass_number& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

mass_number::
mass_number (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

mass_number::
mass_number (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

mass_number::
mass_number (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

mass_number* mass_number::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mass_number (*this, f, c);
}

mass_number::
~mass_number ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::spin_system > r (
      ::spin_system_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::spin_system > r (
      ::xsd::cxx::tree::traits< ::spin_system, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spin_system",
    "");
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::spin_system > r (
      ::xsd::cxx::tree::traits< ::spin_system, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spin_system",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

void
operator<< (::xercesc::DOMElement& e, const vector& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(i.z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const orientation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // euler_angles
  //
  if (i.euler_angles ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "euler_angles",
        e));

    s << *i.euler_angles ();
  }

  // angle_axis
  //
  if (i.angle_axis ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "angle_axis",
        e));

    s << *i.angle_axis ();
  }

  // quaternion
  //
  if (i.quaternion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "quaternion",
        e));

    s << *i.quaternion ();
  }

  // eigensystem
  //
  if (i.eigensystem ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "eigensystem",
        e));

    s << *i.eigensystem ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const interaction& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // scalar
  //
  if (i.scalar ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "scalar",
        e));

    s << *i.scalar ();
  }

  // matrix
  //
  if (i.matrix ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "matrix",
        e));

    s << *i.matrix ();
  }

  // eigenvalues
  //
  if (i.eigenvalues ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "eigenvalues",
        e));

    s << *i.eigenvalues ();
  }

  // axiality_rhombicity
  //
  if (i.axiality_rhombicity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "axiality_rhombicity",
        e));

    s << *i.axiality_rhombicity ();
  }

  // span_skew
  //
  if (i.span_skew ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "span_skew",
        e));

    s << *i.span_skew ();
  }

  // orientation
  //
  if (i.orientation ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "orientation",
        e));

    s << *i.orientation ();
  }

  // type
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "type",
        e));

    a << i.type ();
  }

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }

  // spin_1
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spin_1",
        e));

    a << i.spin_1 ();
  }

  // spin_2
  //
  if (i.spin_2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spin_2",
        e));

    a << *i.spin_2 ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::DOMDocument& d,
              const ::spin_system& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "spin_system",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
spin_system_ (const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "spin_system",
      "",
      m, f));

  ::spin_system_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const euler_angles& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // alpha
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "alpha",
        e));

    a << i.alpha ();
  }

  // beta
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "beta",
        e));

    a << i.beta ();
  }

  // gamma
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "gamma",
        e));

    a << i.gamma ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const angle_axis& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // angle
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "angle",
        e));

    s << i.angle ();
  }

  // axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "axis",
        e));

    s << i.axis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const quaternion& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // re
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "re",
        e));

    a << ::xml_schema::as_double(i.re ());
  }

  // i
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "i",
        e));

    a << ::xml_schema::as_double(i.i ());
  }

  // j
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "j",
        e));

    a << ::xml_schema::as_double(i.j ());
  }

  // k
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "k",
        e));

    a << ::xml_schema::as_double(i.k ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const eigensystem& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x_axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "x_axis",
        e));

    s << i.x_axis ();
  }

  // y_axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "y_axis",
        e));

    s << i.y_axis ();
  }

  // z_axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "z_axis",
        e));

    s << i.z_axis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const scalar& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);

  // strong
  //
  if (i.strong ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "strong",
        e));

    a << *i.strong ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const matrix& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // element
  //
  for (matrix::element_const_iterator
       b (i.element ().begin ()), n (i.element ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "element",
        e));

    s << ::xml_schema::as_double (*b);
  }
}

void
operator<< (::xercesc::DOMElement& e, const eigenvalues& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // XX
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "XX",
        e));

    a << ::xml_schema::as_double(i.XX ());
  }

  // YY
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "YY",
        e));

    a << ::xml_schema::as_double(i.YY ());
  }

  // ZZ
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ZZ",
        e));

    a << ::xml_schema::as_double(i.ZZ ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const axiality_rhombicity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // iso
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "iso",
        e));

    a << ::xml_schema::as_double(i.iso ());
  }

  // ax
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ax",
        e));

    a << ::xml_schema::as_double(i.ax ());
  }

  // rh
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rh",
        e));

    a << ::xml_schema::as_double(i.rh ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const span_skew& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // iso
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "iso",
        e));

    a << ::xml_schema::as_double(i.iso ());
  }

  // span
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "span",
        e));

    a << ::xml_schema::as_double(i.span ());
  }

  // skew
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "skew",
        e));

    a << ::xml_schema::as_double(i.skew ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const type& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const type& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const type& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const spin_1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const spin_1& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const spin_1& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const spin_2& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const spin_2& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const spin_2& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const spin_system& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // spin
  //
  for (spin_system::spin_const_iterator
       b (i.spin ().begin ()), n (i.spin ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spin",
        e));

    s << *b;
  }

  // interaction
  //
  for (spin_system::interaction_const_iterator
       b (i.interaction ().begin ()), n (i.interaction ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "interaction",
        e));

    s << *b;
  }

  // reference_frame
  //
  for (spin_system::reference_frame_const_iterator
       b (i.reference_frame ().begin ()), n (i.reference_frame ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "reference_frame",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const alpha& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const alpha& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const alpha& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const beta& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const beta& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const beta& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const gamma& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const gamma& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const gamma& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const angle& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const angle& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const angle& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const spin& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinates
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinates",
        e));

    s << i.coordinates ();
  }

  // isotope
  //
  for (spin::isotope_const_iterator
       b (i.isotope ().begin ()), n (i.isotope ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "isotope",
        e));

    s << *b;
  }

  // number
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "number",
        e));

    a << i.number ();
  }

  // label
  //
  if (i.label ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "label",
        e));

    a << *i.label ();
  }

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }

  // element
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "element",
        e));

    a << i.element ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const interaction1& i)
{
  e << static_cast< const ::interaction& > (i);

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const reference_frame& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // orientation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "orientation",
        e));

    s << i.orientation ();
  }

  // number
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "number",
        e));

    a << i.number ();
  }

  // label
  //
  if (i.label ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "label",
        e));

    a << *i.label ();
  }

  // reference_frame
  //
  if (i.reference_frame1 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << *i.reference_frame1 ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const isotope& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // abundance
  //
  if (i.abundance ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "abundance",
        e));

    a << *i.abundance ();
  }

  // mass_number
  //
  if (i.mass_number ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mass_number",
        e));

    a << *i.mass_number ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const number& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const number& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const number& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const reference_frame1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const reference_frame1& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const reference_frame1& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const element& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const element& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const element& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const reference_frame2& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const reference_frame2& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const reference_frame2& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const number1& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const number1& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const number1& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const reference_frame3& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const reference_frame3& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const reference_frame3& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const abundance& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const abundance& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const abundance& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const mass_number& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const mass_number& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const mass_number& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

