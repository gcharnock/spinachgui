// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "spinxml_schema.hpp"

// vector
// 

const vector::x_type& vector::
x () const
{
  return this->x_.get ();
}

vector::x_type& vector::
x ()
{
  return this->x_.get ();
}

void vector::
x (const x_type& x)
{
  this->x_.set (x);
}

const vector::y_type& vector::
y () const
{
  return this->y_.get ();
}

vector::y_type& vector::
y ()
{
  return this->y_.get ();
}

void vector::
y (const y_type& x)
{
  this->y_.set (x);
}

const vector::z_type& vector::
z () const
{
  return this->z_.get ();
}

vector::z_type& vector::
z ()
{
  return this->z_.get ();
}

void vector::
z (const z_type& x)
{
  this->z_.set (x);
}

const vector::reference_frame_type& vector::
reference_frame () const
{
  return this->reference_frame_.get ();
}

vector::reference_frame_type& vector::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void vector::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}


// matrix
// 

const matrix::xx_type& matrix::
xx () const
{
  return this->xx_.get ();
}

matrix::xx_type& matrix::
xx ()
{
  return this->xx_.get ();
}

void matrix::
xx (const xx_type& x)
{
  this->xx_.set (x);
}

const matrix::xy_type& matrix::
xy () const
{
  return this->xy_.get ();
}

matrix::xy_type& matrix::
xy ()
{
  return this->xy_.get ();
}

void matrix::
xy (const xy_type& x)
{
  this->xy_.set (x);
}

const matrix::xz_type& matrix::
xz () const
{
  return this->xz_.get ();
}

matrix::xz_type& matrix::
xz ()
{
  return this->xz_.get ();
}

void matrix::
xz (const xz_type& x)
{
  this->xz_.set (x);
}

const matrix::yx_type& matrix::
yx () const
{
  return this->yx_.get ();
}

matrix::yx_type& matrix::
yx ()
{
  return this->yx_.get ();
}

void matrix::
yx (const yx_type& x)
{
  this->yx_.set (x);
}

const matrix::yy_type& matrix::
yy () const
{
  return this->yy_.get ();
}

matrix::yy_type& matrix::
yy ()
{
  return this->yy_.get ();
}

void matrix::
yy (const yy_type& x)
{
  this->yy_.set (x);
}

const matrix::yz_type& matrix::
yz () const
{
  return this->yz_.get ();
}

matrix::yz_type& matrix::
yz ()
{
  return this->yz_.get ();
}

void matrix::
yz (const yz_type& x)
{
  this->yz_.set (x);
}

const matrix::zx_type& matrix::
zx () const
{
  return this->zx_.get ();
}

matrix::zx_type& matrix::
zx ()
{
  return this->zx_.get ();
}

void matrix::
zx (const zx_type& x)
{
  this->zx_.set (x);
}

const matrix::zy_type& matrix::
zy () const
{
  return this->zy_.get ();
}

matrix::zy_type& matrix::
zy ()
{
  return this->zy_.get ();
}

void matrix::
zy (const zy_type& x)
{
  this->zy_.set (x);
}

const matrix::zz_type& matrix::
zz () const
{
  return this->zz_.get ();
}

matrix::zz_type& matrix::
zz ()
{
  return this->zz_.get ();
}

void matrix::
zz (const zz_type& x)
{
  this->zz_.set (x);
}

const matrix::reference_frame_type& matrix::
reference_frame () const
{
  return this->reference_frame_.get ();
}

matrix::reference_frame_type& matrix::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void matrix::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}


// orientation
// 

const orientation::euler_angles_optional& orientation::
euler_angles () const
{
  return this->euler_angles_;
}

orientation::euler_angles_optional& orientation::
euler_angles ()
{
  return this->euler_angles_;
}

void orientation::
euler_angles (const euler_angles_type& x)
{
  this->euler_angles_.set (x);
}

void orientation::
euler_angles (const euler_angles_optional& x)
{
  this->euler_angles_ = x;
}

void orientation::
euler_angles (::std::auto_ptr< euler_angles_type > x)
{
  this->euler_angles_.set (x);
}

const orientation::angle_axis_optional& orientation::
angle_axis () const
{
  return this->angle_axis_;
}

orientation::angle_axis_optional& orientation::
angle_axis ()
{
  return this->angle_axis_;
}

void orientation::
angle_axis (const angle_axis_type& x)
{
  this->angle_axis_.set (x);
}

void orientation::
angle_axis (const angle_axis_optional& x)
{
  this->angle_axis_ = x;
}

void orientation::
angle_axis (::std::auto_ptr< angle_axis_type > x)
{
  this->angle_axis_.set (x);
}

const orientation::quaternion_optional& orientation::
quaternion () const
{
  return this->quaternion_;
}

orientation::quaternion_optional& orientation::
quaternion ()
{
  return this->quaternion_;
}

void orientation::
quaternion (const quaternion_type& x)
{
  this->quaternion_.set (x);
}

void orientation::
quaternion (const quaternion_optional& x)
{
  this->quaternion_ = x;
}

void orientation::
quaternion (::std::auto_ptr< quaternion_type > x)
{
  this->quaternion_.set (x);
}

const orientation::dcm_optional& orientation::
dcm () const
{
  return this->dcm_;
}

orientation::dcm_optional& orientation::
dcm ()
{
  return this->dcm_;
}

void orientation::
dcm (const dcm_type& x)
{
  this->dcm_.set (x);
}

void orientation::
dcm (const dcm_optional& x)
{
  this->dcm_ = x;
}

void orientation::
dcm (::std::auto_ptr< dcm_type > x)
{
  this->dcm_.set (x);
}


// interaction
// 

const interaction::scalar_optional& interaction::
scalar () const
{
  return this->scalar_;
}

interaction::scalar_optional& interaction::
scalar ()
{
  return this->scalar_;
}

void interaction::
scalar (const scalar_type& x)
{
  this->scalar_.set (x);
}

void interaction::
scalar (const scalar_optional& x)
{
  this->scalar_ = x;
}

void interaction::
scalar (::std::auto_ptr< scalar_type > x)
{
  this->scalar_.set (x);
}

const interaction::tensor_optional& interaction::
tensor () const
{
  return this->tensor_;
}

interaction::tensor_optional& interaction::
tensor ()
{
  return this->tensor_;
}

void interaction::
tensor (const tensor_type& x)
{
  this->tensor_.set (x);
}

void interaction::
tensor (const tensor_optional& x)
{
  this->tensor_ = x;
}

void interaction::
tensor (::std::auto_ptr< tensor_type > x)
{
  this->tensor_.set (x);
}

const interaction::eigenvalues_optional& interaction::
eigenvalues () const
{
  return this->eigenvalues_;
}

interaction::eigenvalues_optional& interaction::
eigenvalues ()
{
  return this->eigenvalues_;
}

void interaction::
eigenvalues (const eigenvalues_type& x)
{
  this->eigenvalues_.set (x);
}

void interaction::
eigenvalues (const eigenvalues_optional& x)
{
  this->eigenvalues_ = x;
}

void interaction::
eigenvalues (::std::auto_ptr< eigenvalues_type > x)
{
  this->eigenvalues_.set (x);
}

const interaction::axiality_rhombicity_optional& interaction::
axiality_rhombicity () const
{
  return this->axiality_rhombicity_;
}

interaction::axiality_rhombicity_optional& interaction::
axiality_rhombicity ()
{
  return this->axiality_rhombicity_;
}

void interaction::
axiality_rhombicity (const axiality_rhombicity_type& x)
{
  this->axiality_rhombicity_.set (x);
}

void interaction::
axiality_rhombicity (const axiality_rhombicity_optional& x)
{
  this->axiality_rhombicity_ = x;
}

void interaction::
axiality_rhombicity (::std::auto_ptr< axiality_rhombicity_type > x)
{
  this->axiality_rhombicity_.set (x);
}

const interaction::span_skew_optional& interaction::
span_skew () const
{
  return this->span_skew_;
}

interaction::span_skew_optional& interaction::
span_skew ()
{
  return this->span_skew_;
}

void interaction::
span_skew (const span_skew_type& x)
{
  this->span_skew_.set (x);
}

void interaction::
span_skew (const span_skew_optional& x)
{
  this->span_skew_ = x;
}

void interaction::
span_skew (::std::auto_ptr< span_skew_type > x)
{
  this->span_skew_.set (x);
}

const interaction::orientation_optional& interaction::
orientation () const
{
  return this->orientation_;
}

interaction::orientation_optional& interaction::
orientation ()
{
  return this->orientation_;
}

void interaction::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void interaction::
orientation (const orientation_optional& x)
{
  this->orientation_ = x;
}

void interaction::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const interaction::kind_type& interaction::
kind () const
{
  return this->kind_.get ();
}

interaction::kind_type& interaction::
kind ()
{
  return this->kind_.get ();
}

void interaction::
kind (const kind_type& x)
{
  this->kind_.set (x);
}

void interaction::
kind (::std::auto_ptr< kind_type > x)
{
  this->kind_.set (x);
}

const interaction::units_type& interaction::
units () const
{
  return this->units_.get ();
}

interaction::units_type& interaction::
units ()
{
  return this->units_.get ();
}

void interaction::
units (const units_type& x)
{
  this->units_.set (x);
}

void interaction::
units (::std::auto_ptr< units_type > x)
{
  this->units_.set (x);
}

const interaction::spin_1_type& interaction::
spin_1 () const
{
  return this->spin_1_.get ();
}

interaction::spin_1_type& interaction::
spin_1 ()
{
  return this->spin_1_.get ();
}

void interaction::
spin_1 (const spin_1_type& x)
{
  this->spin_1_.set (x);
}

const interaction::spin_2_optional& interaction::
spin_2 () const
{
  return this->spin_2_;
}

interaction::spin_2_optional& interaction::
spin_2 ()
{
  return this->spin_2_;
}

void interaction::
spin_2 (const spin_2_type& x)
{
  this->spin_2_.set (x);
}

void interaction::
spin_2 (const spin_2_optional& x)
{
  this->spin_2_ = x;
}

const interaction::label_optional& interaction::
label () const
{
  return this->label_;
}

interaction::label_optional& interaction::
label ()
{
  return this->label_;
}

void interaction::
label (const label_type& x)
{
  this->label_.set (x);
}

void interaction::
label (const label_optional& x)
{
  this->label_ = x;
}

void interaction::
label (::std::auto_ptr< label_type > x)
{
  this->label_.set (x);
}


// euler_angles
// 

const euler_angles::alpha_type& euler_angles::
alpha () const
{
  return this->alpha_.get ();
}

euler_angles::alpha_type& euler_angles::
alpha ()
{
  return this->alpha_.get ();
}

void euler_angles::
alpha (const alpha_type& x)
{
  this->alpha_.set (x);
}

const euler_angles::beta_type& euler_angles::
beta () const
{
  return this->beta_.get ();
}

euler_angles::beta_type& euler_angles::
beta ()
{
  return this->beta_.get ();
}

void euler_angles::
beta (const beta_type& x)
{
  this->beta_.set (x);
}

const euler_angles::gamma_type& euler_angles::
gamma () const
{
  return this->gamma_.get ();
}

euler_angles::gamma_type& euler_angles::
gamma ()
{
  return this->gamma_.get ();
}

void euler_angles::
gamma (const gamma_type& x)
{
  this->gamma_.set (x);
}

const euler_angles::reference_frame_type& euler_angles::
reference_frame () const
{
  return this->reference_frame_.get ();
}

euler_angles::reference_frame_type& euler_angles::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void euler_angles::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}


// angle_axis
// 

const angle_axis::angle_type& angle_axis::
angle () const
{
  return this->angle_.get ();
}

angle_axis::angle_type& angle_axis::
angle ()
{
  return this->angle_.get ();
}

void angle_axis::
angle (const angle_type& x)
{
  this->angle_.set (x);
}

const angle_axis::axis_type& angle_axis::
axis () const
{
  return this->axis_.get ();
}

angle_axis::axis_type& angle_axis::
axis ()
{
  return this->axis_.get ();
}

void angle_axis::
axis (const axis_type& x)
{
  this->axis_.set (x);
}

void angle_axis::
axis (::std::auto_ptr< axis_type > x)
{
  this->axis_.set (x);
}


// quaternion
// 

const quaternion::re_type& quaternion::
re () const
{
  return this->re_.get ();
}

quaternion::re_type& quaternion::
re ()
{
  return this->re_.get ();
}

void quaternion::
re (const re_type& x)
{
  this->re_.set (x);
}

const quaternion::i_type& quaternion::
i () const
{
  return this->i_.get ();
}

quaternion::i_type& quaternion::
i ()
{
  return this->i_.get ();
}

void quaternion::
i (const i_type& x)
{
  this->i_.set (x);
}

const quaternion::j_type& quaternion::
j () const
{
  return this->j_.get ();
}

quaternion::j_type& quaternion::
j ()
{
  return this->j_.get ();
}

void quaternion::
j (const j_type& x)
{
  this->j_.set (x);
}

const quaternion::k_type& quaternion::
k () const
{
  return this->k_.get ();
}

quaternion::k_type& quaternion::
k ()
{
  return this->k_.get ();
}

void quaternion::
k (const k_type& x)
{
  this->k_.set (x);
}

const quaternion::reference_frame_type& quaternion::
reference_frame () const
{
  return this->reference_frame_.get ();
}

quaternion::reference_frame_type& quaternion::
reference_frame ()
{
  return this->reference_frame_.get ();
}

void quaternion::
reference_frame (const reference_frame_type& x)
{
  this->reference_frame_.set (x);
}


// scalar
// 


// tensor
// 


// eigenvalues
// 

const eigenvalues::XX_type& eigenvalues::
XX () const
{
  return this->XX_.get ();
}

eigenvalues::XX_type& eigenvalues::
XX ()
{
  return this->XX_.get ();
}

void eigenvalues::
XX (const XX_type& x)
{
  this->XX_.set (x);
}

const eigenvalues::YY_type& eigenvalues::
YY () const
{
  return this->YY_.get ();
}

eigenvalues::YY_type& eigenvalues::
YY ()
{
  return this->YY_.get ();
}

void eigenvalues::
YY (const YY_type& x)
{
  this->YY_.set (x);
}

const eigenvalues::ZZ_type& eigenvalues::
ZZ () const
{
  return this->ZZ_.get ();
}

eigenvalues::ZZ_type& eigenvalues::
ZZ ()
{
  return this->ZZ_.get ();
}

void eigenvalues::
ZZ (const ZZ_type& x)
{
  this->ZZ_.set (x);
}


// axiality_rhombicity
// 

const axiality_rhombicity::iso_type& axiality_rhombicity::
iso () const
{
  return this->iso_.get ();
}

axiality_rhombicity::iso_type& axiality_rhombicity::
iso ()
{
  return this->iso_.get ();
}

void axiality_rhombicity::
iso (const iso_type& x)
{
  this->iso_.set (x);
}

const axiality_rhombicity::ax_type& axiality_rhombicity::
ax () const
{
  return this->ax_.get ();
}

axiality_rhombicity::ax_type& axiality_rhombicity::
ax ()
{
  return this->ax_.get ();
}

void axiality_rhombicity::
ax (const ax_type& x)
{
  this->ax_.set (x);
}

const axiality_rhombicity::rh_type& axiality_rhombicity::
rh () const
{
  return this->rh_.get ();
}

axiality_rhombicity::rh_type& axiality_rhombicity::
rh ()
{
  return this->rh_.get ();
}

void axiality_rhombicity::
rh (const rh_type& x)
{
  this->rh_.set (x);
}


// span_skew
// 

const span_skew::iso_type& span_skew::
iso () const
{
  return this->iso_.get ();
}

span_skew::iso_type& span_skew::
iso ()
{
  return this->iso_.get ();
}

void span_skew::
iso (const iso_type& x)
{
  this->iso_.set (x);
}

const span_skew::span_type& span_skew::
span () const
{
  return this->span_.get ();
}

span_skew::span_type& span_skew::
span ()
{
  return this->span_.get ();
}

void span_skew::
span (const span_type& x)
{
  this->span_.set (x);
}

const span_skew::skew_type& span_skew::
skew () const
{
  return this->skew_.get ();
}

span_skew::skew_type& span_skew::
skew ()
{
  return this->skew_.get ();
}

void span_skew::
skew (const skew_type& x)
{
  this->skew_.set (x);
}


// kind
// 

kind::
kind (value v)
: ::xml_schema::string (_xsd_kind_literals_[v])
{
}

kind::
kind (const char* v)
: ::xml_schema::string (v)
{
}

kind::
kind (const ::std::string& v)
: ::xml_schema::string (v)
{
}

kind::
kind (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

kind::
kind (const kind& v,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

kind& kind::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_kind_literals_[v]);

  return *this;
}


// spin_system
// 

const spin_system::spin_sequence& spin_system::
spin () const
{
  return this->spin_;
}

spin_system::spin_sequence& spin_system::
spin ()
{
  return this->spin_;
}

void spin_system::
spin (const spin_sequence& s)
{
  this->spin_ = s;
}

const spin_system::interaction_sequence& spin_system::
interaction () const
{
  return this->interaction_;
}

spin_system::interaction_sequence& spin_system::
interaction ()
{
  return this->interaction_;
}

void spin_system::
interaction (const interaction_sequence& s)
{
  this->interaction_ = s;
}

const spin_system::reference_frame_sequence& spin_system::
reference_frame () const
{
  return this->reference_frame_;
}

spin_system::reference_frame_sequence& spin_system::
reference_frame ()
{
  return this->reference_frame_;
}

void spin_system::
reference_frame (const reference_frame_sequence& s)
{
  this->reference_frame_ = s;
}


// spin
// 

const spin::coordinates_optional& spin::
coordinates () const
{
  return this->coordinates_;
}

spin::coordinates_optional& spin::
coordinates ()
{
  return this->coordinates_;
}

void spin::
coordinates (const coordinates_type& x)
{
  this->coordinates_.set (x);
}

void spin::
coordinates (const coordinates_optional& x)
{
  this->coordinates_ = x;
}

void spin::
coordinates (::std::auto_ptr< coordinates_type > x)
{
  this->coordinates_.set (x);
}

const spin::number_type& spin::
number () const
{
  return this->number_.get ();
}

spin::number_type& spin::
number ()
{
  return this->number_.get ();
}

void spin::
number (const number_type& x)
{
  this->number_.set (x);
}

const spin::isotope_type& spin::
isotope () const
{
  return this->isotope_.get ();
}

spin::isotope_type& spin::
isotope ()
{
  return this->isotope_.get ();
}

void spin::
isotope (const isotope_type& x)
{
  this->isotope_.set (x);
}

void spin::
isotope (::std::auto_ptr< isotope_type > x)
{
  this->isotope_.set (x);
}

const spin::label_optional& spin::
label () const
{
  return this->label_;
}

spin::label_optional& spin::
label ()
{
  return this->label_;
}

void spin::
label (const label_type& x)
{
  this->label_.set (x);
}

void spin::
label (const label_optional& x)
{
  this->label_ = x;
}

void spin::
label (::std::auto_ptr< label_type > x)
{
  this->label_.set (x);
}


// interaction1
// 


// reference_frame
// 

const reference_frame::origin_type& reference_frame::
origin () const
{
  return this->origin_.get ();
}

reference_frame::origin_type& reference_frame::
origin ()
{
  return this->origin_.get ();
}

void reference_frame::
origin (const origin_type& x)
{
  this->origin_.set (x);
}

void reference_frame::
origin (::std::auto_ptr< origin_type > x)
{
  this->origin_.set (x);
}

const reference_frame::orientation_type& reference_frame::
orientation () const
{
  return this->orientation_.get ();
}

reference_frame::orientation_type& reference_frame::
orientation ()
{
  return this->orientation_.get ();
}

void reference_frame::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void reference_frame::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const reference_frame::number_type& reference_frame::
number () const
{
  return this->number_.get ();
}

reference_frame::number_type& reference_frame::
number ()
{
  return this->number_.get ();
}

void reference_frame::
number (const number_type& x)
{
  this->number_.set (x);
}

const reference_frame::label_optional& reference_frame::
label () const
{
  return this->label_;
}

reference_frame::label_optional& reference_frame::
label ()
{
  return this->label_;
}

void reference_frame::
label (const label_type& x)
{
  this->label_.set (x);
}

void reference_frame::
label (const label_optional& x)
{
  this->label_ = x;
}

void reference_frame::
label (::std::auto_ptr< label_type > x)
{
  this->label_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// vector
//

vector::
vector (const x_type& x,
        const y_type& y,
        const z_type& z,
        const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  x_ (x, ::xml_schema::flags (), this),
  y_ (y, ::xml_schema::flags (), this),
  z_ (z, ::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this)
{
}

vector::
vector (const vector& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

vector::
vector (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (f, this),
  y_ (f, this),
  z_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      this->x_.set (x_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      this->y_.set (y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      this->z_.set (z_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      this->reference_frame_.set (reference_frame_traits::create (i, f, this));
      continue;
    }
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }
}

vector* vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class vector (*this, f, c);
}

vector::
~vector ()
{
}

// matrix
//

matrix::
matrix (const xx_type& xx,
        const xy_type& xy,
        const xz_type& xz,
        const yx_type& yx,
        const yy_type& yy,
        const yz_type& yz,
        const zx_type& zx,
        const zy_type& zy,
        const zz_type& zz,
        const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  xx_ (xx, ::xml_schema::flags (), this),
  xy_ (xy, ::xml_schema::flags (), this),
  xz_ (xz, ::xml_schema::flags (), this),
  yx_ (yx, ::xml_schema::flags (), this),
  yy_ (yy, ::xml_schema::flags (), this),
  yz_ (yz, ::xml_schema::flags (), this),
  zx_ (zx, ::xml_schema::flags (), this),
  zy_ (zy, ::xml_schema::flags (), this),
  zz_ (zz, ::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this)
{
}

matrix::
matrix (const matrix& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  xx_ (x.xx_, f, this),
  xy_ (x.xy_, f, this),
  xz_ (x.xz_, f, this),
  yx_ (x.yx_, f, this),
  yy_ (x.yy_, f, this),
  yz_ (x.yz_, f, this),
  zx_ (x.zx_, f, this),
  zy_ (x.zy_, f, this),
  zz_ (x.zz_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

matrix::
matrix (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  xx_ (f, this),
  xy_ (f, this),
  xz_ (f, this),
  yx_ (f, this),
  yy_ (f, this),
  yz_ (f, this),
  zx_ (f, this),
  zy_ (f, this),
  zz_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void matrix::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "xx" && n.namespace_ ().empty ())
    {
      this->xx_.set (xx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xy" && n.namespace_ ().empty ())
    {
      this->xy_.set (xy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "xz" && n.namespace_ ().empty ())
    {
      this->xz_.set (xz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yx" && n.namespace_ ().empty ())
    {
      this->yx_.set (yx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yy" && n.namespace_ ().empty ())
    {
      this->yy_.set (yy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "yz" && n.namespace_ ().empty ())
    {
      this->yz_.set (yz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zx" && n.namespace_ ().empty ())
    {
      this->zx_.set (zx_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zy" && n.namespace_ ().empty ())
    {
      this->zy_.set (zy_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "zz" && n.namespace_ ().empty ())
    {
      this->zz_.set (zz_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      this->reference_frame_.set (reference_frame_traits::create (i, f, this));
      continue;
    }
  }

  if (!xx_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xx",
      "");
  }

  if (!xy_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xy",
      "");
  }

  if (!xz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "xz",
      "");
  }

  if (!yx_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yx",
      "");
  }

  if (!yy_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yy",
      "");
  }

  if (!yz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "yz",
      "");
  }

  if (!zx_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zx",
      "");
  }

  if (!zy_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zy",
      "");
  }

  if (!zz_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "zz",
      "");
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }
}

matrix* matrix::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class matrix (*this, f, c);
}

matrix::
~matrix ()
{
}

// orientation
//

orientation::
orientation ()
: ::xml_schema::type (),
  euler_angles_ (::xml_schema::flags (), this),
  angle_axis_ (::xml_schema::flags (), this),
  quaternion_ (::xml_schema::flags (), this),
  dcm_ (::xml_schema::flags (), this)
{
}

orientation::
orientation (const orientation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  euler_angles_ (x.euler_angles_, f, this),
  angle_axis_ (x.angle_axis_, f, this),
  quaternion_ (x.quaternion_, f, this),
  dcm_ (x.dcm_, f, this)
{
}

orientation::
orientation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  euler_angles_ (f, this),
  angle_axis_ (f, this),
  quaternion_ (f, this),
  dcm_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void orientation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // euler_angles
    //
    if (n.name () == "euler_angles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< euler_angles_type > r (
        euler_angles_traits::create (i, f, this));

      if (!this->euler_angles_)
      {
        this->euler_angles_.set (r);
        continue;
      }
    }

    // angle_axis
    //
    if (n.name () == "angle_axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< angle_axis_type > r (
        angle_axis_traits::create (i, f, this));

      if (!this->angle_axis_)
      {
        this->angle_axis_.set (r);
        continue;
      }
    }

    // quaternion
    //
    if (n.name () == "quaternion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< quaternion_type > r (
        quaternion_traits::create (i, f, this));

      if (!this->quaternion_)
      {
        this->quaternion_.set (r);
        continue;
      }
    }

    // dcm
    //
    if (n.name () == "dcm" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dcm_type > r (
        dcm_traits::create (i, f, this));

      if (!this->dcm_)
      {
        this->dcm_.set (r);
        continue;
      }
    }

    break;
  }
}

orientation* orientation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class orientation (*this, f, c);
}

orientation::
~orientation ()
{
}

// interaction
//

interaction::
interaction (const kind_type& kind,
             const units_type& units,
             const spin_1_type& spin_1)
: ::xml_schema::type (),
  scalar_ (::xml_schema::flags (), this),
  tensor_ (::xml_schema::flags (), this),
  eigenvalues_ (::xml_schema::flags (), this),
  axiality_rhombicity_ (::xml_schema::flags (), this),
  span_skew_ (::xml_schema::flags (), this),
  orientation_ (::xml_schema::flags (), this),
  kind_ (kind, ::xml_schema::flags (), this),
  units_ (units, ::xml_schema::flags (), this),
  spin_1_ (spin_1, ::xml_schema::flags (), this),
  spin_2_ (::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this)
{
}

interaction::
interaction (const interaction& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  scalar_ (x.scalar_, f, this),
  tensor_ (x.tensor_, f, this),
  eigenvalues_ (x.eigenvalues_, f, this),
  axiality_rhombicity_ (x.axiality_rhombicity_, f, this),
  span_skew_ (x.span_skew_, f, this),
  orientation_ (x.orientation_, f, this),
  kind_ (x.kind_, f, this),
  units_ (x.units_, f, this),
  spin_1_ (x.spin_1_, f, this),
  spin_2_ (x.spin_2_, f, this),
  label_ (x.label_, f, this)
{
}

interaction::
interaction (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  scalar_ (f, this),
  tensor_ (f, this),
  eigenvalues_ (f, this),
  axiality_rhombicity_ (f, this),
  span_skew_ (f, this),
  orientation_ (f, this),
  kind_ (f, this),
  units_ (f, this),
  spin_1_ (f, this),
  spin_2_ (f, this),
  label_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void interaction::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // scalar
    //
    if (n.name () == "scalar" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scalar_type > r (
        scalar_traits::create (i, f, this));

      if (!this->scalar_)
      {
        this->scalar_.set (r);
        continue;
      }
    }

    // tensor
    //
    if (n.name () == "tensor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tensor_type > r (
        tensor_traits::create (i, f, this));

      if (!this->tensor_)
      {
        this->tensor_.set (r);
        continue;
      }
    }

    // eigenvalues
    //
    if (n.name () == "eigenvalues" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eigenvalues_type > r (
        eigenvalues_traits::create (i, f, this));

      if (!this->eigenvalues_)
      {
        this->eigenvalues_.set (r);
        continue;
      }
    }

    // axiality_rhombicity
    //
    if (n.name () == "axiality_rhombicity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axiality_rhombicity_type > r (
        axiality_rhombicity_traits::create (i, f, this));

      if (!this->axiality_rhombicity_)
      {
        this->axiality_rhombicity_.set (r);
        continue;
      }
    }

    // span_skew
    //
    if (n.name () == "span_skew" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< span_skew_type > r (
        span_skew_traits::create (i, f, this));

      if (!this->span_skew_)
      {
        this->span_skew_.set (r);
        continue;
      }
    }

    // orientation
    //
    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      if (!this->orientation_)
      {
        this->orientation_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "kind" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< kind_type > r (
        kind_traits::create (i, f, this));

      this->kind_.set (r);
      continue;
    }

    if (n.name () == "units" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< units_type > r (
        units_traits::create (i, f, this));

      this->units_.set (r);
      continue;
    }

    if (n.name () == "spin_1" && n.namespace_ ().empty ())
    {
      this->spin_1_.set (spin_1_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "spin_2" && n.namespace_ ().empty ())
    {
      this->spin_2_.set (spin_2_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< label_type > r (
        label_traits::create (i, f, this));

      this->label_.set (r);
      continue;
    }
  }

  if (!kind_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "kind",
      "");
  }

  if (!units_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "units",
      "");
  }

  if (!spin_1_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "spin_1",
      "");
  }
}

interaction* interaction::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class interaction (*this, f, c);
}

interaction::
~interaction ()
{
}

// euler_angles
//

euler_angles::
euler_angles (const alpha_type& alpha,
              const beta_type& beta,
              const gamma_type& gamma,
              const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  alpha_ (alpha, ::xml_schema::flags (), this),
  beta_ (beta, ::xml_schema::flags (), this),
  gamma_ (gamma, ::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this)
{
}

euler_angles::
euler_angles (const euler_angles& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  alpha_ (x.alpha_, f, this),
  beta_ (x.beta_, f, this),
  gamma_ (x.gamma_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

euler_angles::
euler_angles (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  alpha_ (f, this),
  beta_ (f, this),
  gamma_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void euler_angles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "alpha" && n.namespace_ ().empty ())
    {
      this->alpha_.set (alpha_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "beta" && n.namespace_ ().empty ())
    {
      this->beta_.set (beta_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gamma" && n.namespace_ ().empty ())
    {
      this->gamma_.set (gamma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      this->reference_frame_.set (reference_frame_traits::create (i, f, this));
      continue;
    }
  }

  if (!alpha_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "alpha",
      "");
  }

  if (!beta_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "beta",
      "");
  }

  if (!gamma_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "gamma",
      "");
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }
}

euler_angles* euler_angles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class euler_angles (*this, f, c);
}

euler_angles::
~euler_angles ()
{
}

// angle_axis
//

angle_axis::
angle_axis (const angle_type& angle,
            const axis_type& axis)
: ::xml_schema::type (),
  angle_ (angle, ::xml_schema::flags (), this),
  axis_ (axis, ::xml_schema::flags (), this)
{
}

angle_axis::
angle_axis (const angle_type& angle,
            ::std::auto_ptr< axis_type >& axis)
: ::xml_schema::type (),
  angle_ (angle, ::xml_schema::flags (), this),
  axis_ (axis, ::xml_schema::flags (), this)
{
}

angle_axis::
angle_axis (const angle_axis& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  angle_ (x.angle_, f, this),
  axis_ (x.axis_, f, this)
{
}

angle_axis::
angle_axis (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  angle_ (f, this),
  axis_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void angle_axis::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // angle
    //
    if (n.name () == "angle" && n.namespace_ ().empty ())
    {
      if (!angle_.present ())
      {
        this->angle_.set (angle_traits::create (i, f, this));
        continue;
      }
    }

    // axis
    //
    if (n.name () == "axis" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axis_type > r (
        axis_traits::create (i, f, this));

      if (!axis_.present ())
      {
        this->axis_.set (r);
        continue;
      }
    }

    break;
  }

  if (!angle_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "angle",
      "");
  }

  if (!axis_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "axis",
      "");
  }
}

angle_axis* angle_axis::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class angle_axis (*this, f, c);
}

angle_axis::
~angle_axis ()
{
}

// quaternion
//

quaternion::
quaternion (const re_type& re,
            const i_type& i,
            const j_type& j,
            const k_type& k,
            const reference_frame_type& reference_frame)
: ::xml_schema::type (),
  re_ (re, ::xml_schema::flags (), this),
  i_ (i, ::xml_schema::flags (), this),
  j_ (j, ::xml_schema::flags (), this),
  k_ (k, ::xml_schema::flags (), this),
  reference_frame_ (reference_frame, ::xml_schema::flags (), this)
{
}

quaternion::
quaternion (const quaternion& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  re_ (x.re_, f, this),
  i_ (x.i_, f, this),
  j_ (x.j_, f, this),
  k_ (x.k_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

quaternion::
quaternion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  re_ (f, this),
  i_ (f, this),
  j_ (f, this),
  k_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void quaternion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "re" && n.namespace_ ().empty ())
    {
      this->re_.set (re_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "i" && n.namespace_ ().empty ())
    {
      this->i_.set (i_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "j" && n.namespace_ ().empty ())
    {
      this->j_.set (j_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      this->k_.set (k_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      this->reference_frame_.set (reference_frame_traits::create (i, f, this));
      continue;
    }
  }

  if (!re_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "re",
      "");
  }

  if (!i_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "i",
      "");
  }

  if (!j_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "j",
      "");
  }

  if (!k_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "k",
      "");
  }

  if (!reference_frame_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "reference_frame",
      "");
  }
}

quaternion* quaternion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class quaternion (*this, f, c);
}

quaternion::
~quaternion ()
{
}

// scalar
//

scalar::
scalar (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

scalar::
scalar (const scalar& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

scalar::
scalar (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

scalar::
scalar (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

scalar::
scalar (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

scalar* scalar::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class scalar (*this, f, c);
}

scalar::
~scalar ()
{
}

// tensor
//

tensor::
tensor (const xx_type& xx,
        const xy_type& xy,
        const xz_type& xz,
        const yx_type& yx,
        const yy_type& yy,
        const yz_type& yz,
        const zx_type& zx,
        const zy_type& zy,
        const zz_type& zz,
        const reference_frame_type& reference_frame)
: ::matrix (xx,
            xy,
            xz,
            yx,
            yy,
            yz,
            zx,
            zy,
            zz,
            reference_frame)
{
}

tensor::
tensor (const tensor& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::matrix (x, f, c)
{
}

tensor::
tensor (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::matrix (e, f, c)
{
}

tensor* tensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tensor (*this, f, c);
}

tensor::
~tensor ()
{
}

// eigenvalues
//

eigenvalues::
eigenvalues (const XX_type& XX,
             const YY_type& YY,
             const ZZ_type& ZZ)
: ::xml_schema::type (),
  XX_ (XX, ::xml_schema::flags (), this),
  YY_ (YY, ::xml_schema::flags (), this),
  ZZ_ (ZZ, ::xml_schema::flags (), this)
{
}

eigenvalues::
eigenvalues (const eigenvalues& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  XX_ (x.XX_, f, this),
  YY_ (x.YY_, f, this),
  ZZ_ (x.ZZ_, f, this)
{
}

eigenvalues::
eigenvalues (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  XX_ (f, this),
  YY_ (f, this),
  ZZ_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void eigenvalues::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "XX" && n.namespace_ ().empty ())
    {
      this->XX_.set (XX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "YY" && n.namespace_ ().empty ())
    {
      this->YY_.set (YY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ZZ" && n.namespace_ ().empty ())
    {
      this->ZZ_.set (ZZ_traits::create (i, f, this));
      continue;
    }
  }

  if (!XX_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "XX",
      "");
  }

  if (!YY_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "YY",
      "");
  }

  if (!ZZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ZZ",
      "");
  }
}

eigenvalues* eigenvalues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class eigenvalues (*this, f, c);
}

eigenvalues::
~eigenvalues ()
{
}

// axiality_rhombicity
//

axiality_rhombicity::
axiality_rhombicity (const iso_type& iso,
                     const ax_type& ax,
                     const rh_type& rh)
: ::xml_schema::type (),
  iso_ (iso, ::xml_schema::flags (), this),
  ax_ (ax, ::xml_schema::flags (), this),
  rh_ (rh, ::xml_schema::flags (), this)
{
}

axiality_rhombicity::
axiality_rhombicity (const axiality_rhombicity& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  iso_ (x.iso_, f, this),
  ax_ (x.ax_, f, this),
  rh_ (x.rh_, f, this)
{
}

axiality_rhombicity::
axiality_rhombicity (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  iso_ (f, this),
  ax_ (f, this),
  rh_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void axiality_rhombicity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "iso" && n.namespace_ ().empty ())
    {
      this->iso_.set (iso_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "ax" && n.namespace_ ().empty ())
    {
      this->ax_.set (ax_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rh" && n.namespace_ ().empty ())
    {
      this->rh_.set (rh_traits::create (i, f, this));
      continue;
    }
  }

  if (!iso_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iso",
      "");
  }

  if (!ax_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ax",
      "");
  }

  if (!rh_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "rh",
      "");
  }
}

axiality_rhombicity* axiality_rhombicity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class axiality_rhombicity (*this, f, c);
}

axiality_rhombicity::
~axiality_rhombicity ()
{
}

// span_skew
//

span_skew::
span_skew (const iso_type& iso,
           const span_type& span,
           const skew_type& skew)
: ::xml_schema::type (),
  iso_ (iso, ::xml_schema::flags (), this),
  span_ (span, ::xml_schema::flags (), this),
  skew_ (skew, ::xml_schema::flags (), this)
{
}

span_skew::
span_skew (const span_skew& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  iso_ (x.iso_, f, this),
  span_ (x.span_, f, this),
  skew_ (x.skew_, f, this)
{
}

span_skew::
span_skew (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  iso_ (f, this),
  span_ (f, this),
  skew_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void span_skew::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "iso" && n.namespace_ ().empty ())
    {
      this->iso_.set (iso_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "span" && n.namespace_ ().empty ())
    {
      this->span_.set (span_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "skew" && n.namespace_ ().empty ())
    {
      this->skew_.set (skew_traits::create (i, f, this));
      continue;
    }
  }

  if (!iso_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "iso",
      "");
  }

  if (!span_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "span",
      "");
  }

  if (!skew_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "skew",
      "");
  }
}

span_skew* span_skew::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class span_skew (*this, f, c);
}

span_skew::
~span_skew ()
{
}

// kind
//

kind::
kind (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_kind_convert ();
}

kind::
kind (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_kind_convert ();
}

kind::
kind (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_kind_convert ();
}

kind* kind::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class kind (*this, f, c);
}

kind::value kind::
_xsd_kind_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_kind_literals_);
  const value* i (::std::lower_bound (
                    _xsd_kind_indexes_,
                    _xsd_kind_indexes_ + 9,
                    *this,
                    c));

  if (i == _xsd_kind_indexes_ + 9 || _xsd_kind_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const kind::
_xsd_kind_literals_[9] =
{
  "hfc",
  "shielding",
  "quadrupolar",
  "scalar",
  "dipolar",
  "g-tenser",
  "zfs",
  "exchange",
  "custem"
};

const kind::value kind::
_xsd_kind_indexes_[9] =
{
  ::kind::custem,
  ::kind::dipolar,
  ::kind::exchange,
  ::kind::g_tenser,
  ::kind::hfc,
  ::kind::quadrupolar,
  ::kind::scalar,
  ::kind::shielding,
  ::kind::zfs
};

// spin_system
//

spin_system::
spin_system ()
: ::xml_schema::type (),
  spin_ (::xml_schema::flags (), this),
  interaction_ (::xml_schema::flags (), this),
  reference_frame_ (::xml_schema::flags (), this)
{
}

spin_system::
spin_system (const spin_system& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  spin_ (x.spin_, f, this),
  interaction_ (x.interaction_, f, this),
  reference_frame_ (x.reference_frame_, f, this)
{
}

spin_system::
spin_system (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  spin_ (f, this),
  interaction_ (f, this),
  reference_frame_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void spin_system::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // spin
    //
    if (n.name () == "spin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spin_type > r (
        spin_traits::create (i, f, this));

      this->spin_.push_back (r);
      continue;
    }

    // interaction
    //
    if (n.name () == "interaction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< interaction_type > r (
        interaction_traits::create (i, f, this));

      this->interaction_.push_back (r);
      continue;
    }

    // reference_frame
    //
    if (n.name () == "reference_frame" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_frame_type > r (
        reference_frame_traits::create (i, f, this));

      this->reference_frame_.push_back (r);
      continue;
    }

    break;
  }
}

spin_system* spin_system::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin_system (*this, f, c);
}

spin_system::
~spin_system ()
{
}

// spin
//

spin::
spin (const number_type& number,
      const isotope_type& isotope)
: ::xml_schema::type (),
  coordinates_ (::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  isotope_ (isotope, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this)
{
}

spin::
spin (const spin& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinates_ (x.coordinates_, f, this),
  number_ (x.number_, f, this),
  isotope_ (x.isotope_, f, this),
  label_ (x.label_, f, this)
{
}

spin::
spin (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinates_ (f, this),
  number_ (f, this),
  isotope_ (f, this),
  label_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void spin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinates
    //
    if (n.name () == "coordinates" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordinates_type > r (
        coordinates_traits::create (i, f, this));

      if (!this->coordinates_)
      {
        this->coordinates_.set (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "number" && n.namespace_ ().empty ())
    {
      this->number_.set (number_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "isotope" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< isotope_type > r (
        isotope_traits::create (i, f, this));

      this->isotope_.set (r);
      continue;
    }

    if (n.name () == "label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< label_type > r (
        label_traits::create (i, f, this));

      this->label_.set (r);
      continue;
    }
  }

  if (!number_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "number",
      "");
  }

  if (!isotope_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "isotope",
      "");
  }
}

spin* spin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class spin (*this, f, c);
}

spin::
~spin ()
{
}

// interaction1
//

interaction1::
interaction1 (const kind_type& kind,
              const units_type& units,
              const spin_1_type& spin_1)
: ::interaction (kind,
                 units,
                 spin_1)
{
}

interaction1::
interaction1 (const interaction1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::interaction (x, f, c)
{
}

interaction1::
interaction1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::interaction (e, f, c)
{
}

interaction1* interaction1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class interaction1 (*this, f, c);
}

interaction1::
~interaction1 ()
{
}

// reference_frame
//

reference_frame::
reference_frame (const origin_type& origin,
                 const orientation_type& orientation,
                 const number_type& number)
: ::xml_schema::type (),
  origin_ (origin, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this)
{
}

reference_frame::
reference_frame (::std::auto_ptr< origin_type >& origin,
                 ::std::auto_ptr< orientation_type >& orientation,
                 const number_type& number)
: ::xml_schema::type (),
  origin_ (origin, ::xml_schema::flags (), this),
  orientation_ (orientation, ::xml_schema::flags (), this),
  number_ (number, ::xml_schema::flags (), this),
  label_ (::xml_schema::flags (), this)
{
}

reference_frame::
reference_frame (const reference_frame& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  origin_ (x.origin_, f, this),
  orientation_ (x.orientation_, f, this),
  number_ (x.number_, f, this),
  label_ (x.label_, f, this)
{
}

reference_frame::
reference_frame (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  origin_ (f, this),
  orientation_ (f, this),
  number_ (f, this),
  label_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
    this->parse (p, f);
  }
}

void reference_frame::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // origin
    //
    if (n.name () == "origin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< origin_type > r (
        origin_traits::create (i, f, this));

      if (!origin_.present ())
      {
        this->origin_.set (r);
        continue;
      }
    }

    // orientation
    //
    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      if (!orientation_.present ())
      {
        this->orientation_.set (r);
        continue;
      }
    }

    break;
  }

  if (!origin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "origin",
      "");
  }

  if (!orientation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "orientation",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "number" && n.namespace_ ().empty ())
    {
      this->number_.set (number_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "label" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< label_type > r (
        label_traits::create (i, f, this));

      this->label_.set (r);
      continue;
    }
  }

  if (!number_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "number",
      "");
  }
}

reference_frame* reference_frame::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class reference_frame (*this, f, c);
}

reference_frame::
~reference_frame ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::std::string& u,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::std::istream& is,
              const ::std::string& sid,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::spin_system_ (isrc, h, f, p);
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xml_schema::error_handler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xercesc::InputSource& i,
              ::xercesc::DOMErrorHandler& h,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::spin_system > r (
    ::spin_system_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::spin_system >
spin_system_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::spin_system > r (
      ::spin_system_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::spin_system > r (
      ::xsd::cxx::tree::traits< ::spin_system, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spin_system",
    "");
}

::std::auto_ptr< ::spin_system >
spin_system_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
              ::xml_schema::flags f,
              const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::spin_system > r (
      ::xsd::cxx::tree::traits< ::spin_system, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "spin_system",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/serialization-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

void
operator<< (::xercesc::DOMElement& e, const vector& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // x
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "x",
        e));

    a << ::xml_schema::as_double(i.x ());
  }

  // y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "y",
        e));

    a << ::xml_schema::as_double(i.y ());
  }

  // z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "z",
        e));

    a << ::xml_schema::as_double(i.z ());
  }

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const matrix& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // xx
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xx",
        e));

    a << ::xml_schema::as_double(i.xx ());
  }

  // xy
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xy",
        e));

    a << ::xml_schema::as_double(i.xy ());
  }

  // xz
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "xz",
        e));

    a << ::xml_schema::as_double(i.xz ());
  }

  // yx
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "yx",
        e));

    a << ::xml_schema::as_double(i.yx ());
  }

  // yy
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "yy",
        e));

    a << ::xml_schema::as_double(i.yy ());
  }

  // yz
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "yz",
        e));

    a << ::xml_schema::as_double(i.yz ());
  }

  // zx
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zx",
        e));

    a << ::xml_schema::as_double(i.zx ());
  }

  // zy
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zy",
        e));

    a << ::xml_schema::as_double(i.zy ());
  }

  // zz
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "zz",
        e));

    a << ::xml_schema::as_double(i.zz ());
  }

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const orientation& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // euler_angles
  //
  if (i.euler_angles ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "euler_angles",
        e));

    s << *i.euler_angles ();
  }

  // angle_axis
  //
  if (i.angle_axis ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "angle_axis",
        e));

    s << *i.angle_axis ();
  }

  // quaternion
  //
  if (i.quaternion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "quaternion",
        e));

    s << *i.quaternion ();
  }

  // dcm
  //
  if (i.dcm ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "dcm",
        e));

    s << *i.dcm ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const interaction& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // scalar
  //
  if (i.scalar ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "scalar",
        e));

    s << *i.scalar ();
  }

  // tensor
  //
  if (i.tensor ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "tensor",
        e));

    s << *i.tensor ();
  }

  // eigenvalues
  //
  if (i.eigenvalues ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "eigenvalues",
        e));

    s << *i.eigenvalues ();
  }

  // axiality_rhombicity
  //
  if (i.axiality_rhombicity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "axiality_rhombicity",
        e));

    s << *i.axiality_rhombicity ();
  }

  // span_skew
  //
  if (i.span_skew ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "span_skew",
        e));

    s << *i.span_skew ();
  }

  // orientation
  //
  if (i.orientation ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "orientation",
        e));

    s << *i.orientation ();
  }

  // kind
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "kind",
        e));

    a << i.kind ();
  }

  // units
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "units",
        e));

    a << i.units ();
  }

  // spin_1
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spin_1",
        e));

    a << i.spin_1 ();
  }

  // spin_2
  //
  if (i.spin_2 ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "spin_2",
        e));

    a << *i.spin_2 ();
  }

  // label
  //
  if (i.label ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "label",
        e));

    a << *i.label ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::std::ostream& o,
              const ::spin_system& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              ::xml_schema::error_handler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::XMLFormatTarget& t,
              const ::spin_system& s,
              ::xercesc::DOMErrorHandler& h,
              const ::xml_schema::namespace_infomap& m,
              const ::std::string& e,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::spin_system_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
spin_system_ (::xercesc::DOMDocument& d,
              const ::spin_system& s,
              ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "spin_system" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "spin_system",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
spin_system_ (const ::spin_system& s,
              const ::xml_schema::namespace_infomap& m,
              ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "spin_system",
      "",
      m, f));

  ::spin_system_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const euler_angles& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // alpha
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "alpha",
        e));

    a << ::xml_schema::as_double(i.alpha ());
  }

  // beta
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "beta",
        e));

    a << ::xml_schema::as_double(i.beta ());
  }

  // gamma
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "gamma",
        e));

    a << ::xml_schema::as_double(i.gamma ());
  }

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const angle_axis& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // angle
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "angle",
        e));

    s << ::xml_schema::as_double(i.angle ());
  }

  // axis
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "axis",
        e));

    s << i.axis ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const quaternion& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // re
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "re",
        e));

    a << ::xml_schema::as_double(i.re ());
  }

  // i
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "i",
        e));

    a << ::xml_schema::as_double(i.i ());
  }

  // j
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "j",
        e));

    a << ::xml_schema::as_double(i.j ());
  }

  // k
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "k",
        e));

    a << ::xml_schema::as_double(i.k ());
  }

  // reference_frame
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "reference_frame",
        e));

    a << i.reference_frame ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const scalar& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,const scalar& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const scalar& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const tensor& i)
{
  e << static_cast< const ::matrix& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const eigenvalues& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // XX
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "XX",
        e));

    a << ::xml_schema::as_double(i.XX ());
  }

  // YY
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "YY",
        e));

    a << ::xml_schema::as_double(i.YY ());
  }

  // ZZ
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ZZ",
        e));

    a << ::xml_schema::as_double(i.ZZ ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const axiality_rhombicity& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // iso
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "iso",
        e));

    a << ::xml_schema::as_double(i.iso ());
  }

  // ax
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ax",
        e));

    a << ::xml_schema::as_double(i.ax ());
  }

  // rh
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "rh",
        e));

    a << ::xml_schema::as_double(i.rh ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const span_skew& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // iso
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "iso",
        e));

    a << ::xml_schema::as_double(i.iso ());
  }

  // span
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "span",
        e));

    a << ::xml_schema::as_double(i.span ());
  }

  // skew
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "skew",
        e));

    a << ::xml_schema::as_double(i.skew ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const kind& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const kind& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const kind& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const spin_system& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // spin
  //
  for (spin_system::spin_const_iterator
       b (i.spin ().begin ()), n (i.spin ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "spin",
        e));

    s << *b;
  }

  // interaction
  //
  for (spin_system::interaction_const_iterator
       b (i.interaction ().begin ()), n (i.interaction ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "interaction",
        e));

    s << *b;
  }

  // reference_frame
  //
  for (spin_system::reference_frame_const_iterator
       b (i.reference_frame ().begin ()), n (i.reference_frame ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "reference_frame",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const spin& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // coordinates
  //
  if (i.coordinates ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "coordinates",
        e));

    s << *i.coordinates ();
  }

  // number
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "number",
        e));

    a << i.number ();
  }

  // isotope
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "isotope",
        e));

    a << i.isotope ();
  }

  // label
  //
  if (i.label ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "label",
        e));

    a << *i.label ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const interaction1& i)
{
  e << static_cast< const ::interaction& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const reference_frame& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // origin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "origin",
        e));

    s << i.origin ();
  }

  // orientation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "orientation",
        e));

    s << i.orientation ();
  }

  // number
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "number",
        e));

    a << i.number ();
  }

  // label
  //
  if (i.label ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "label",
        e));

    a << *i.label ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

